<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glowing Sphere - Star Collector Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0f0f1a 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent browser zooming/scrolling on mobile */
            user-select: none;
            -webkit-user-select: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        canvas {
            display: block;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            pointer-events: none;
        }
        
        #hud h2 {
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.8);
        }

        #score, #stars-left, #lives, #seed-display {
            font-size: 16px;
            margin: 4px 0;
            opacity: 0.9;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            #hud h2 {
                font-size: 18px;
            }

            #score, #stars-left, #lives, #seed-display {
                font-size: 12px;
            }

            #instructions {
                font-size: 11px;
                padding: 8px 15px;
            }

            #currency-display {
                font-size: 14px;
            }

            #power-ups-display {
                font-size: 12px;
            }

            #virtual-joystick {
                width: 100px;
                height: 100px;
            }

            #joystick-handle {
                width: 40px;
                height: 40px;
            }

            .touch-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }
        
        #score span, #stars-left span, #lives span, #seed-display span {
            color: #66ccff;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(100, 200, 255, 0.6);
        }
        
        #seed-display {
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        #seed-display:hover {
            color: #88ddff;
        }
        
        #instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        /* Controller icon styles */
        .controller-icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            vertical-align: middle;
            margin: 0 4px;
        }

        .xbox-icon {
            background: linear-gradient(135deg, #107C10 0%, #0E6B0E 100%);
            border-radius: 50%;
            position: relative;
        }

        .xbox-icon::before {
            content: 'X';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .keyboard-icon {
            background: linear-gradient(135deg, #333 0%, #222 100%);
            border-radius: 4px;
            position: relative;
        }

        .keyboard-icon::before {
            content: '‚å®';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
        }

        .touch-icon {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            border-radius: 4px;
            position: relative;
        }

        .touch-icon::before {
            content: 'üëÜ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
        }
        
        #game-over, #level-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 200;
            display: none;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px 60px;
            border-radius: 20px;
            border: 2px solid rgba(100, 200, 255, 0.5);
        }
        
        #game-over h1, #level-complete h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 100, 100, 0.8);
        }
        
        #level-complete h1 {
            text-shadow: 0 0 20px rgba(100, 255, 100, 0.8);
        }
        
        #game-over p, #level-complete p {
            font-size: 18px;
            margin: 10px 0;
        }
        
        #seed-input-container {
            margin: 20px 0;
        }
        
        #seed-input {
            padding: 10px 20px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 10px;
            color: white;
            width: 200px;
            text-align: center;
        }
        
        #seed-input:focus {
            outline: none;
            border-color: rgba(100, 200, 255, 0.8);
        }
        
        #restart-btn, #restart-stage-btn, #next-level-btn, #play-seed-btn {
            padding: 15px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #66ccff 0%, #9966ff 100%);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: auto;
            margin: 10px 5px;
        }
        
        #restart-btn:hover, #restart-stage-btn:hover, #next-level-btn:hover, #play-seed-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(100, 200, 255, 0.6);
        }
        
        #level-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            z-index: 100;
            pointer-events: none;
        }

        #currency-display {
            position: absolute;
            top: 70px;
            left: 20px;
            color: rgba(255, 215, 0, 0.9);
            font-size: 18px;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #power-ups-display {
            position: absolute;
            top: 100px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
        }

        #power-ups-display .power-up-slot {
            display: inline-block;
            margin-right: 5px;
            padding: 3px 8px;
            background: rgba(100, 200, 255, 0.2);
            border-radius: 5px;
            border: 1px solid rgba(100, 200, 255, 0.4);
        }

        #shield-indicator {
            position: absolute;
            top: 130px;
            left: 20px;
            color: rgba(100, 255, 100, 0.9);
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
            display: none;
            text-shadow: 0 0 10px rgba(100, 255, 100, 0.6);
        }

        #dash-indicator {
            position: absolute;
            top: 155px;
            left: 20px;
            color: rgba(255, 200, 50, 0.9);
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
            display: block;
            text-shadow: 0 0 10px rgba(255, 200, 50, 0.6);
        }

        #dash-indicator span {
            color: rgba(100, 200, 255, 0.9);
            font-weight: bold;
        }

        #pause-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 48px;
            font-weight: bold;
            z-index: 250;
            pointer-events: none;
            display: none;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            letter-spacing: 5px;
        }

        #seed-toast {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(100, 200, 255, 0.2);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            z-index: 150;
            display: none;
            pointer-events: none;
        }

        #shop-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 40px;
            border-radius: 20px;
            border: 2px solid rgba(100, 200, 255, 0.5);
            color: white;
            z-index: 300;
            display: none;
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #shop-menu h1 {
            text-align: center;
            font-size: 36px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
        }

        #shop-currency {
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
            color: #ffd700;
        }

        #shop-content {
            display: flex;
            gap: 20px;
        }

        .shop-column {
            flex: 1;
        }

        .shop-column h2 {
            font-size: 20px;
            margin-bottom: 15px;
            color: #66ccff;
            border-bottom: 2px solid rgba(100, 200, 255, 0.3);
            padding-bottom: 5px;
        }

        .power-up-item {
            background: rgba(50, 50, 80, 0.6);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 10px;
            border: 1px solid rgba(100, 200, 255, 0.3);
            transition: all 0.3s;
        }

        .power-up-item:hover {
            border-color: rgba(100, 200, 255, 0.6);
            background: rgba(60, 60, 90, 0.7);
        }

        .power-up-item.owned {
            border-color: rgba(100, 255, 100, 0.5);
            background: rgba(50, 80, 50, 0.4);
        }

        .power-up-item.equipped {
            border-color: rgba(255, 215, 0, 0.6);
            background: rgba(80, 70, 30, 0.5);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .power-up-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .power-up-name {
            font-size: 18px;
            font-weight: bold;
        }

        .power-up-icon {
            font-size: 24px;
        }

        .power-up-description {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
        }

        .power-up-level {
            font-size: 12px;
            color: #88ddff;
            margin-bottom: 8px;
        }

        .power-up-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .shop-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: linear-gradient(135deg, #66ccff 0%, #9966ff 100%);
            border: none;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .shop-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.5);
        }

        .shop-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .shop-btn.equip {
            background: linear-gradient(135deg, #66ff66 0%, #33cc33 100%);
        }

        .shop-btn.unequip {
            background: linear-gradient(135deg, #ff6666 0%, #cc3333 100%);
        }

        .shop-btn.close {
            background: linear-gradient(135deg, #666666 0%, #444444 100%);
            margin-top: 10px;
        }

        .shop-btn.reset {
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
            margin-top: 10px;
        }

        .cost-display {
            font-size: 14px;
            color: #ffd700;
            margin-left: auto;
        }

        .slots-info {
            font-size: 14px;
            color: #88ddff;
            margin-bottom: 15px;
        }

        #close-shop-btn {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            margin-top: 20px;
        }

        /* Touch Controls for Mobile */
        #touch-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 150;
            display: none;
            pointer-events: none;
        }

        #virtual-joystick {
            width: 120px;
            height: 120px;
            background: rgba(100, 200, 255, 0.2);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            touch-action: none;
        }

        #joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(100, 200, 255, 0.6);
            border: 2px solid rgba(100, 200, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #touch-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 150;
            display: none;
            pointer-events: none;
        }

        .touch-btn {
            width: 60px;
            height: 60px;
            background: rgba(100, 200, 255, 0.2);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 50%;
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }

        .touch-btn:active {
            background: rgba(100, 200, 255, 0.4);
        }

        #touch-buttons-row {
            display: flex;
            gap: 10px;
        }

        /* Controller Status */
        #controller-status {
            position: absolute;
            bottom: 75px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(100, 255, 100, 0.8);
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
            display: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 15px;
        }

        #controller-status.disconnected {
            color: rgba(255, 100, 100, 0.8);
        }

        /* Focus indicators for controller navigation */
        .focusable {
            transition: all 0.2s ease;
            outline: none;
        }

        .focusable:focus,
        .focusable.controller-focused {
            outline: 3px solid rgba(100, 200, 255, 0.8);
            outline-offset: 3px;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.6);
            transform: scale(1.05);
            z-index: 10;
        }

        .shop-btn.focusable:focus,
        .shop-btn.focusable.controller-focused {
            outline-width: 2px;
        }

        .power-up-item.focusable:focus,
        .power-up-item.focusable.controller-focused {
            outline-color: rgba(255, 215, 0, 0.8);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        /* Navigation hints */
        .nav-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        #shop-nav-hint, #game-over-nav-hint, #level-complete-nav-hint {
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="hud">
        <h2>‚≠ê Star Collector</h2>
        <div id="score">Score: <span id="score-value">0</span></div>
        <div id="stars-left">Stars: <span id="stars-value">0</span></div>
        <div id="lives">Lives: <span id="lives-value">3</span></div>
        <div id="seed-display" onclick="copySeed()">Seed: <span id="seed-value">Random</span> üìã</div>
    </div>
    
    <div id="level-indicator">Level: <span id="level-value">1</span></div>
    
    <div id="currency-display">üí∞ <span id="coins-value">0</span></div>
    
    <div id="power-ups-display"></div>
    
    <div id="shield-indicator">üõ°Ô∏è Shield Active: <span id="shield-time">0.0</span>s</div>
    
    <div id="dash-indicator">‚ö° Dash: <span id="dash-status">READY</span> | üõë Break: <span id="break-status">READY</span></div>
    
    <div id="pause-indicator">‚è∏Ô∏è PAUSED</div>
    
    <div id="instructions">
        WASD/Arrows ‚Ä¢ Controller (Left Stick/D-pad) ‚Ä¢ Touch (Mobile) ‚Ä¢ 'B'/Start for Shop
    </div>

    <!-- Touch Controls for Mobile -->
    <div id="touch-controls">
        <div id="virtual-joystick">
            <div id="joystick-handle"></div>
        </div>
    </div>

    <div id="touch-buttons">
        <div id="touch-buttons-row">
            <button class="touch-btn" id="touch-shop-btn" aria-label="Shop">üõí</button>
        </div>
    </div>

    <!-- Controller Status -->
    <div id="controller-status">üéÆ Controller Connected</div>

    <div id="seed-toast">Seed copied to clipboard!</div>
    
    <div id="game-over">
        <h1>Game Over!</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <p>Level Reached: <span id="final-level">1</span></p>
        <div id="seed-input-container">
            <input type="text" id="seed-input" class="focusable" placeholder="Enter seed to replay" maxlength="20">
        </div>
        <button id="play-seed-btn" class="focusable">Play Seed</button>
        <button id="restart-stage-btn" class="focusable">Restart Stage</button>
        <button id="restart-btn" class="focusable">New Random</button>
        <div id="game-over-nav-hint" class="nav-hint">üéÆ D-pad/Stick: Navigate ‚Ä¢ A/‚úì: Select</div>
    </div>

    <div id="level-complete">
        <h1>Level Complete!</h1>
        <p>Score: <span id="level-score">0</span></p>
        <p>Time: <span id="level-time">0</span>s</p>
        <p>Coins Earned: <span id="level-coins">0</span> üí∞</p>
        <button id="next-level-btn" class="focusable">Next Level</button>
        <button id="shop-btn-complete" class="focusable">Open Shop</button>
        <div id="level-complete-nav-hint" class="nav-hint">üéÆ D-pad/Stick: Navigate ‚Ä¢ A/‚úì: Select</div>
    </div>
    
    <div id="shop-menu">
        <h1>‚ö° Power-Up Shop ‚ö°</h1>
        <div id="shop-currency">üí∞ <span id="shop-coins-value">0</span> Coins</div>

        <div class="slots-info">
            Active Power-Ups: <span id="active-slots-count">0</span> / <span id="max-slots-count">3</span>
        </div>

        <div id="shop-content">
            <div class="shop-column">
                <h2>üì¶ Available Power-Ups</h2>
                <div id="available-power-ups"></div>
            </div>

            <div class="shop-column">
                <h2>üéØ Your Collection</h2>
                <div id="owned-power-ups"></div>
            </div>
        </div>

        <button id="close-shop-btn" class="shop-btn close focusable">Close Shop</button>
        <button id="reset-progress-btn" class="shop-btn reset focusable">Reset All Progress</button>
        <div id="shop-nav-hint" class="nav-hint">üéÆ D-pad/Stick: Navigate ‚Ä¢ A: Select ‚Ä¢ B/Start: Close</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Save/Load System
        function saveProgress() {
            const saveData = {
                coins: playerProgress.coins,
                powerUps: playerProgress.powerUps,
                activePowerUps: playerProgress.activePowerUps,
                highScores: playerProgress.highScores,
                totalLevelsCompleted: playerProgress.totalLevelsCompleted,
                version: '1.0'
            };
            localStorage.setItem('glowingSphereProgress', JSON.stringify(saveData));
        }

        function loadProgress() {
            const saved = localStorage.getItem('glowingSphereProgress');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    playerProgress.coins = data.coins || 0;
                    playerProgress.powerUps = data.powerUps || {};
                    playerProgress.activePowerUps = data.activePowerUps || [];
                    playerProgress.highScores = data.highScores || {};
                    playerProgress.totalLevelsCompleted = data.totalLevelsCompleted || 0;
                } catch (e) {
                    console.error('Failed to load progress:', e);
                }
            }
        }

        function resetProgress() {
            localStorage.removeItem('glowingSphereProgress');
            playerProgress.coins = 0;
            playerProgress.powerUps = {};
            playerProgress.activePowerUps = [];
            playerProgress.highScores = {};
            playerProgress.totalLevelsCompleted = 0;
            updateShopUI();
        }

        // Power-up Utilities
        function getPowerUpCost(powerUpId, currentLevel) {
            const powerUp = POWER_UPS[powerUpId];
            if (!powerUp) return 0;
            return Math.floor(powerUp.baseCost * Math.pow(powerUp.costMultiplier, currentLevel));
        }

        function getPowerUpLevel(powerUpId) {
            return playerProgress.powerUps[powerUpId] || 0;
        }

        function canPurchasePowerUp(powerUpId) {
            const currentLevel = getPowerUpLevel(powerUpId);
            const powerUp = POWER_UPS[powerUpId];
            if (currentLevel >= powerUp.maxLevel) return false;
            const cost = getPowerUpCost(powerUpId, currentLevel);
            return playerProgress.coins >= cost;
        }

        function purchasePowerUp(powerUpId) {
            if (!canPurchasePowerUp(powerUpId)) return false;
            
            const currentLevel = getPowerUpLevel(powerUpId);
            const cost = getPowerUpCost(powerUpId, currentLevel);
            
            playerProgress.coins -= cost;
            playerProgress.powerUps[powerUpId] = currentLevel + 1;
            
            saveProgress();
            updateShopUI();
            return true;
        }

        function equipPowerUp(powerUpId) {
            if (playerProgress.activePowerUps.includes(powerUpId)) return;
            if (playerProgress.activePowerUps.length >= playerProgress.maxPowerUpSlots) return;
            if (!playerProgress.powerUps[powerUpId] || playerProgress.powerUps[powerUpId] === 0) return;
            
            playerProgress.activePowerUps.push(powerUpId);
            saveProgress();
            updateShopUI();
        }

        function unequipPowerUp(powerUpId) {
            const index = playerProgress.activePowerUps.indexOf(powerUpId);
            if (index > -1) {
                playerProgress.activePowerUps.splice(index, 1);
                saveProgress();
                updateShopUI();
            }
        }

        function applyPowerUpEffects() {
            gameState.activePowerUpEffects = {};
            
            playerProgress.activePowerUps.forEach(powerUpId => {
                const level = playerProgress.powerUps[powerUpId];
                if (level && level > 0) {
                    const powerUp = POWER_UPS[powerUpId];
                    const effect = powerUp.effect(level);
                    Object.assign(gameState.activePowerUpEffects, effect);
                }
            });
        }

        function calculateCoinsReward(level, timeTaken) {
            // Base coins for completing level
            let baseCoins = 10 + (level * 5);
            
            // Time bonus (faster = more coins)
            // Target time: 60 seconds for level 1, increases by 10s per level
            const targetTime = 60 + (level * 10);
            const timeBonus = Math.max(0, Math.floor((targetTime - timeTaken) * 2));
            
            // Lives bonus
            const livesBonus = gameState.lives * 10;
            
            let totalCoins = baseCoins + timeBonus + livesBonus;
            
            // Apply coin magnet power-up
            if (gameState.activePowerUpEffects.coinBonus) {
                totalCoins = Math.floor(totalCoins * (1 + gameState.activePowerUpEffects.coinBonus));
            }
            
            return Math.max(5, totalCoins); // Minimum 5 coins
        }

        // Seeded Random Number Generator
        class SeededRandom {
            constructor(seed) {
                this.seed = this.hashString(seed.toString());
                this.originalSeed = this.seed;
            }
            
            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash) || 1;
            }
            
            next() {
                this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff;
                return this.seed / 0x7fffffff;
            }
            
            nextFloat(min, max) {
                return min + this.next() * (max - min);
            }
            
            nextInt(min, max) {
                return Math.floor(this.nextFloat(min, max + 1));
            }
            
            reset() {
                this.seed = this.originalSeed;
            }
        }
        
        // Power-up Definitions
        const POWER_UPS = {
            speedBoost: {
                id: 'speedBoost',
                name: 'Speed Boost',
                description: 'Increase movement speed by 15%',
                icon: '‚ö°',
                maxLevel: 5,
                baseCost: 50,
                costMultiplier: 1.8,
                effect: (level) => ({ speed: 1 + (level * 0.15) })
            },
            shield: {
                id: 'shield',
                name: 'Energy Shield',
                description: 'Gain temporary invincibility after taking damage',
                icon: 'üõ°Ô∏è',
                maxLevel: 3,
                baseCost: 75,
                costMultiplier: 2.0,
                effect: (level) => ({ shieldDuration: level * 2 })
            },
            magnet: {
                id: 'magnet',
                name: 'Star Magnet',
                description: 'Auto-collect stars from increased distance',
                icon: 'üß≤',
                maxLevel: 5,
                baseCost: 60,
                costMultiplier: 1.7,
                effect: (level) => ({ magnetRange: 1.5 + (level * 0.8) })
            },
            scoreMultiplier: {
                id: 'scoreMultiplier',
                name: 'Score Multiplier',
                description: 'Increase score gained from stars',
                icon: '‚ú®',
                maxLevel: 5,
                baseCost: 80,
                costMultiplier: 1.9,
                effect: (level) => ({ multiplier: 1 + (level * 0.25) })
            },
            extraLife: {
                id: 'extraLife',
                name: 'Extra Life',
                description: 'Start each level with +1 life',
                icon: '‚ù§Ô∏è',
                maxLevel: 3,
                baseCost: 100,
                costMultiplier: 2.5,
                effect: (level) => ({ extraLives: level })
            },
            enemySlow: {
                id: 'enemySlow',
                name: 'Time Dilation',
                description: 'Enemies move 10% slower per level',
                icon: '‚è∞',
                maxLevel: 4,
                baseCost: 90,
                costMultiplier: 2.0,
                effect: (level) => ({ enemySpeed: 1 - (level * 0.1) })
            },
            starVision: {
                id: 'starVision',
                name: 'Star Vision',
                description: 'See stars through obstacles',
                icon: 'üëÅÔ∏è',
                maxLevel: 1,
                baseCost: 150,
                costMultiplier: 1.0,
                effect: (level) => ({ vision: true })
            },
            coinMagnet: {
                id: 'coinMagnet',
                name: 'Coin Magnet',
                description: 'Earn 10% more coins per level',
                icon: 'üí∞',
                maxLevel: 3,
                baseCost: 70,
                costMultiplier: 2.2,
                effect: (level) => ({ coinBonus: level * 0.1 })
            }
        };

        // Player Progress Data (persistent)
        const playerProgress = {
            coins: 0,
            powerUps: {}, // { powerUpId: level }
            activePowerUps: [], // Array of powerUpIds (max 3 slots)
            maxPowerUpSlots: 3,
            highScores: {},
            totalLevelsCompleted: 0
        };

        // Game State
        const gameState = {
            score: 0,
            lives: 3,
            level: 1,
            starsCollected: 0,
            totalStars: 0,
            isGameOver: false,
            isLevelComplete: false,
            seed: null,
            rng: null,
            levelStartTime: 0,
            levelCompletionTime: 0,
            activePowerUpEffects: {},
            coinsEarned: 0
        };
        
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Camera position
        camera.position.set(0, 25, 15);
        camera.lookAt(0, 0, 0);
        
        // Arena dimensions
        const arenaWidth = 30;
        const arenaHeight = 20;
        
        // Create arena floor with grid
        const floorGeometry = new THREE.PlaneGeometry(arenaWidth, arenaHeight, 30, 20);
        const floorMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                level: { value: 1 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform float level;
                varying vec2 vUv;
                void main() {
                    vec2 grid = abs(fract(vUv * vec2(30.0, 20.0) - 0.5) - 0.5) / fwidth(vUv * vec2(30.0, 20.0));
                    float line = min(grid.x, grid.y);
                    float glow = 1.0 - min(line, 1.0);
                    float pulse = sin(time * 2.0) * 0.3 + 0.7;
                    
                    // Color shifts with level
                    vec3 baseColor = mix(vec3(0.05, 0.05, 0.15), vec3(0.1, 0.05, 0.15), level / 10.0);
                    vec3 gridColor = mix(vec3(0.2, 0.3, 0.5), vec3(0.4, 0.2, 0.5), level / 10.0);
                    
                    vec3 color = mix(baseColor, gridColor, glow * pulse * 0.3);
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -2;
        scene.add(floor);
        
        // Create boundary walls
        function createBoundary(x, z, width, depth, level) {
            const geometry = new THREE.BoxGeometry(width, 2, depth);
            const intensity = 0.5 + level * 0.1;
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    level: { value: level }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float level;
                    varying vec3 vPosition;
                    void main() {
                        float pulse = sin(time * (3.0 + level * 0.5) + vPosition.x * 0.5) * 0.3 + 0.7;
                        vec3 color = mix(vec3(1.0, 0.2, 0.3), vec3(1.0, 0.4, 0.2), level / 10.0) * pulse;
                        float edge = smoothstep(0.8, 1.0, abs(vPosition.x / 0.5));
                        color += vec3(1.0, 0.5, 0.5) * edge;
                        gl_FragColor = vec4(color, 0.8);
                    }
                `,
                transparent: true
            });
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, 0, z);
            scene.add(wall);
            return wall;
        }
        
        let walls = [];
        
        function createWalls(level) {
            walls.forEach(w => scene.remove(w));
            walls = [];
            walls.push(createBoundary(0, -arenaHeight/2 - 1, arenaWidth + 2, 2, level));
            walls.push(createBoundary(0, arenaHeight/2 + 1, arenaWidth + 2, 2, level));
            walls.push(createBoundary(-arenaWidth/2 - 1, 0, 2, arenaHeight + 2, level));
            walls.push(createBoundary(arenaWidth/2 + 1, 0, 2, arenaHeight + 2, level));
        }
        
        // Player sphere
        const sphereGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        const sphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vec3 viewDir = normalize(cameraPosition - vPosition);
                    float fresnel = pow(1.0 - dot(vNormal, viewDir), 2.0);
                    float pulse = sin(time * 4.0) * 0.2 + 0.8;
                    vec3 color = mix(vec3(0.2, 0.5, 1.0), vec3(0.5, 0.2, 1.0), vPosition.y * 0.5 + 0.5);
                    color += vec3(0.3, 0.6, 1.0) * fresnel * 2.0 * pulse;
                    gl_FragColor = vec4(color, 0.9);
                }
            `,
            transparent: true
        });
        
        const player = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(player);
        
        // Player glow
        const glowGeometry = new THREE.SphereGeometry(1.2, 16, 16);
        const glowMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vNormal;
                void main() {
                    float glow = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    float pulse = sin(time * 3.0) * 0.3 + 0.7;
                    gl_FragColor = vec4(0.3, 0.6, 1.0, glow * 0.5 * pulse);
                }
            `,
            transparent: true,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending
        });
        const playerGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        player.add(playerGlow);

        // Shooting star trail effect (multiple segments for dash)
        const trailSegments = 8;
        const dashTrailSegments = [];
        
        for (let i = 0; i < trailSegments; i++) {
            const size = 0.8 - (i * 0.08); // Smaller segments further back
            const opacity = 0.5 - (i * 0.05); // More transparent further back
            
            const trailGeometry = new THREE.SphereGeometry(size, 16, 16);
            const trailMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: opacity }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vec3 viewDir = normalize(cameraPosition - vPosition);
                        float fresnel = pow(1.0 - dot(vNormal, viewDir), 2.0);
                        float pulse = sin(time * 8.0) * 0.3 + 0.7;
                        
                        // Color gradient from cyan to white to orange like a shooting star
                        vec3 color = mix(vec3(0.5, 0.8, 1.0), vec3(1.0, 0.9, 0.5), vPosition.y * 0.5 + 0.5);
                        color += vec3(0.3, 0.6, 1.0) * fresnel * 2.0 * pulse;
                        
                        gl_FragColor = vec4(color, opacity * pulse);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const trailSegment = new THREE.Mesh(trailGeometry, trailMaterial);
            trailSegment.visible = false;
            scene.add(trailSegment);
            dashTrailSegments.push(trailSegment);
        }

        // Break shield indicator (appears in front of sphere when breaking)
        const shieldGeometry = new THREE.CircleGeometry(1.2, 32);
        const shieldMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 center = vUv - 0.5;
                    float dist = length(center);
                    float ring = smoothstep(0.3, 0.4, dist) * smoothstep(0.5, 0.4, dist);
                    float pulse = sin(time * 6.0) * 0.3 + 0.7;
                    vec3 shieldColor = vec3(1.0, 0.5, 0.2) * ring * pulse;
                    float alpha = ring * pulse * 0.6;
                    gl_FragColor = vec4(shieldColor, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const breakShield = new THREE.Mesh(shieldGeometry, shieldMaterial);
        breakShield.visible = false;
        scene.add(breakShield);
        
        // Player physics
        const playerPhysics = {
            position: new THREE.Vector3(0, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            acceleration: 0.18,     // Acceleration for responsive controls
            friction: 0.985,        // Friction for controlled sliding
            maxSpeed: 0.25,         // Maximum speed
            radius: 0.8,
            // Dash mechanics - one-time boost to max speed + 10%
            dashSpeedBoost: 2.0,    // Speed boost multiplier (max speed + 100%)
            dashDuration: 0.3,      // How long the boosted speed is maintained
            dashCooldown: 1.5,      // Cooldown between dashes in seconds
            dashActive: false,      // Is dash currently active
            dashTimeRemaining: 0,   // Time remaining on dash
            dashCooldownRemaining: 0, // Time remaining on cooldown
            // Handbrake mechanics - noticeable slowdown while maintaining drift
            handbrakeFriction: 0.92, // Slows down noticeably but allows drift (8% slowdown per frame)
            handbrakeDuration: 0.6, // Drift duration
            handbrakeActive: false, // Is handbrake currently active
            handbrakeTimeRemaining: 0, // Time remaining on handbrake
            handbrakeCooldownRemaining: 0 // Time remaining on handbrake cooldown
        };
        
        // Collectibles (stars)
        const stars = [];
        
        function createStar(x, z) {
            const group = new THREE.Group();
            
            // Core
            const coreGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.9
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            group.add(core);
            
            // Points
            for (let i = 0; i < 5; i++) {
                const pointGeometry = new THREE.ConeGeometry(0.15, 0.6, 4);
                const pointMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffdd00,
                    transparent: true,
                    opacity: 0.8
                });
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.rotation.z = (i * Math.PI * 2) / 5;
                point.position.y = Math.cos(point.rotation.z) * 0.3;
                point.position.x = Math.sin(point.rotation.z) * 0.3;
                point.rotation.x = Math.PI / 2;
                group.add(point);
            }
            
            // Glow
            const glowGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.2
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);
            
            group.position.set(x, 0, z);
            group.userData = { 
                collected: false,
                baseY: 0,
                rotationSpeed: 2 + Math.random() * 2
            };
            
            scene.add(group);
            stars.push(group);
            return group;
        }
        
        // Obstacles
        const obstacles = [];
        
        function createObstacle(x, z, width, depth, isMoving, moveSpeed, moveRange, moveAxis, level) {
            const geometry = new THREE.BoxGeometry(width, 1.5, depth);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    level: { value: level }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float level;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    void main() {
                        float pulse = sin(time * (2.0 + level * 0.2)) * 0.3 + 0.7;
                        vec3 color = mix(vec3(1.0, 0.2, 0.1), vec3(1.0, 0.3, 0.15), level / 10.0) * pulse;
                        float edge = 1.0 - abs(dot(vNormal, vec3(0.0, 1.0, 0.0)));
                        color += vec3(0.5, 0.1, 0.0) * edge;
                        gl_FragColor = vec4(color, 0.9);
                    }
                `,
                transparent: true
            });
            const obstacle = new THREE.Mesh(geometry, material);
            obstacle.position.set(x, 0, z);
            obstacle.userData = {
                width: width,
                depth: depth,
                isMoving: isMoving,
                moveSpeed: moveSpeed,
                moveRange: moveRange,
                baseX: x,
                baseZ: z,
                moveAxis: moveAxis
            };
            scene.add(obstacle);
            obstacles.push(obstacle);
            return obstacle;
        }
        
        // Enemy Chaser
        let enemy = null;
        let enemyData = null;
        
        function createEnemy(x, z, level) {
            const group = new THREE.Group();
            
            // Main body
            const bodyGeometry = new THREE.SphereGeometry(1.1, 24, 24);
            const bodyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    level: { value: level }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float level;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vec3 viewDir = normalize(cameraPosition - vPosition);
                        float fresnel = pow(1.0 - dot(vNormal, viewDir), 2.0);
                        float pulse = sin(time * (5.0 + level * 0.3)) * 0.3 + 0.7;
                        vec3 coreColor = mix(vec3(1.0, 0.1, 0.1), vec3(1.0, 0.15, 0.05), level / 10.0);
                        vec3 glowColor = mix(vec3(1.0, 0.3, 0.1), vec3(1.0, 0.4, 0.15), level / 10.0);
                        vec3 color = mix(coreColor, glowColor, fresnel);
                        color *= pulse;
                        gl_FragColor = vec4(color, 0.9);
                    }
                `,
                transparent: true
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            
            // Spikes - more spikes on higher levels
            const spikeCount = 6 + Math.floor(level / 2);
            for (let i = 0; i < spikeCount; i++) {
                const spikeGeometry = new THREE.ConeGeometry(0.12, 0.6, 4);
                const spikeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff2222,
                    transparent: true,
                    opacity: 0.9
                });
                const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                const angle = (i / spikeCount) * Math.PI * 2;
                spike.position.x = Math.cos(angle) * 1.15;
                spike.position.z = Math.sin(angle) * 1.15;
                spike.rotation.z = -Math.sin(angle) * Math.PI / 2;
                spike.rotation.x = Math.cos(angle) * Math.PI / 2;
                group.add(spike);
            }
            
            // Eyes (creepy factor)
            for (let i = 0; i < 2; i++) {
                const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff
                });
                const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye.position.set(i === 0 ? -0.3 : 0.3, 0.2, 0.8);
                group.add(eye);
                
                // Pupil
                const pupilGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const pupilMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000
                });
                const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                pupil.position.set(i === 0 ? -0.3 : 0.3, 0.2, 0.92);
                group.add(pupil);
            }
            
            // Outer glow
            const glowGeometry = new THREE.SphereGeometry(1.6, 16, 16);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vNormal;
                    void main() {
                        float glow = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        float pulse = sin(time * 4.0) * 0.4 + 0.6;
                        gl_FragColor = vec4(1.0, 0.2, 0.1, glow * 0.5 * pulse);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);
            
            group.position.set(x, 0, z);
            scene.add(group);
            
            // Enemy gets faster and smarter on higher levels - MORE AGGRESSIVE
            // Apply power-up effects (Time Dilation)
            let speedMultiplier = 1.0;
            if (gameState.activePowerUpEffects.enemySpeed) {
                speedMultiplier = gameState.activePowerUpEffects.enemySpeed;
            }
            
            enemy = group;
            enemyData = {
                position: new THREE.Vector3(x, 0, z),
                velocity: new THREE.Vector3(0, 0, 0),
                speed: (0.08 + level * 0.02) * speedMultiplier,         // Faster on higher levels, affected by power-ups
                acceleration: (0.04 + level * 0.005) * speedMultiplier,  // Better acceleration on higher levels
                pushForce: 0.9 + level * 0.1,        // Stronger push on higher levels
                radius: 1.1,
                chargeCooldown: 0,
                charging: false,
                chargeDirection: new THREE.Vector3(),
                smartBehavior: level >= 2,           // Gets smarter at level 2+
                predictPlayer: level >= 4,           // Predicts player movement at level 4+
                wallHuntMode: level >= 3             // Actively hunts to push player into walls at level 3+
            };
            
            return group;
        }
        
        // Additional enemies for higher levels
        let enemies = [];
        let enemiesData = [];
        
        function createAdditionalEnemy(x, z, level, index) {
            const group = new THREE.Group();
            group.userData = { isEnemy: true, index: index };
            
            // Slightly smaller body for additional enemies
            const bodyGeometry = new THREE.SphereGeometry(0.9, 20, 20);
            const bodyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    level: { value: level }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float level;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vec3 viewDir = normalize(cameraPosition - vPosition);
                        float fresnel = pow(1.0 - dot(vNormal, viewDir), 2.0);
                        float pulse = sin(time * (6.0 + level * 0.4)) * 0.3 + 0.7;
                        vec3 coreColor = mix(vec3(1.0, 0.3, 0.1), vec3(1.0, 0.5, 0.1), level / 10.0);
                        vec3 glowColor = mix(vec3(1.0, 0.5, 0.2), vec3(1.0, 0.6, 0.3), level / 10.0);
                        vec3 color = mix(coreColor, glowColor, fresnel);
                        color *= pulse;
                        gl_FragColor = vec4(color, 0.9);
                    }
                `,
                transparent: true
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            
            // Fewer spikes for additional enemies
            const spikeCount = 4;
            for (let i = 0; i < spikeCount; i++) {
                const spikeGeometry = new THREE.ConeGeometry(0.1, 0.5, 4);
                const spikeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff4422,
                    transparent: true,
                    opacity: 0.9
                });
                const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                const angle = (i / spikeCount) * Math.PI * 2;
                spike.position.x = Math.cos(angle) * 0.95;
                spike.position.z = Math.sin(angle) * 0.95;
                spike.rotation.z = -Math.sin(angle) * Math.PI / 2;
                spike.rotation.x = Math.cos(angle) * Math.PI / 2;
                group.add(spike);
            }
            
            // Glow
            const glowGeometry = new THREE.SphereGeometry(1.3, 12, 12);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vNormal;
                    void main() {
                        float glow = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        float pulse = sin(time * 5.0) * 0.4 + 0.6;
                        gl_FragColor = vec4(1.0, 0.3, 0.1, glow * 0.4 * pulse);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);
            
            group.position.set(x, 0, z);
            scene.add(group);
            enemies.push(group);
            
            // Additional enemies are slightly slower but still dangerous
            // Apply power-up effects (Time Dilation)
            let speedMultiplier = 1.0;
            if (gameState.activePowerUpEffects.enemySpeed) {
                speedMultiplier = gameState.activePowerUpEffects.enemySpeed;
            }
            
            enemiesData.push({
                position: new THREE.Vector3(x, 0, z),
                velocity: new THREE.Vector3(0, 0, 0),
                speed: (0.06 + level * 0.015) * speedMultiplier,
                acceleration: (0.03 + level * 0.003) * speedMultiplier,
                pushForce: 0.7 + level * 0.08,
                radius: 0.9,
                index: index,
                smartBehavior: level >= 5,
                predictPlayer: level >= 7,
                wallHuntMode: level >= 6
            });
            
            return group;
        }
        
        // Moving walls for higher levels
        let movingWalls = [];
        let movingWallsData = [];
        
        function createMovingWall(x, z, length, thickness, isHorizontal, moveSpeed, moveRange, level) {
            const geometry = new THREE.BoxGeometry(
                isHorizontal ? length : thickness,
                2,
                isHorizontal ? thickness : length
            );
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    level: { value: level }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float level;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    void main() {
                        float pulse = sin(time * (3.0 + level * 0.3)) * 0.4 + 0.6;
                        vec3 color = mix(vec3(1.0, 0.4, 0.1), vec3(1.0, 0.6, 0.2), level / 15.0) * pulse;
                        float edge = 1.0 - abs(dot(vNormal, vec3(0.0, 1.0, 0.0)));
                        color += vec3(0.8, 0.3, 0.1) * edge * 0.5;
                        gl_FragColor = vec4(color, 0.85);
                    }
                `,
                transparent: true
            });
            
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, 0, z);
            scene.add(wall);
            
            movingWalls.push(wall);
            movingWallsData.push({
                baseX: x,
                baseZ: z,
                isHorizontal: isHorizontal,
                moveSpeed: moveSpeed,
                moveRange: moveRange,
                length: length,
                thickness: thickness
            });
            
            return wall;
        }
        
        // Level generation with seed
        function generateLevel(level, seed = null) {
            // Start level timer
            gameState.levelStartTime = Date.now();
            
            // Clear existing objects
            stars.forEach(star => scene.remove(star));
            obstacles.forEach(obs => scene.remove(obs));
            stars.length = 0;
            obstacles.length = 0;
            
            // Clear all enemies (including additional ones)
            enemies.forEach(e => scene.remove(e));
            enemies = [];
            enemiesData = [];
            
            // Clear moving walls
            movingWalls.forEach(w => scene.remove(w));
            movingWalls = [];
            movingWallsData = [];
            
            if (enemy) {
                scene.remove(enemy);
                enemy = null;
                enemyData = null;
            }
            
            // Set seed
            if (seed) {
                gameState.seed = seed;
            } else if (!gameState.seed) {
                gameState.seed = Math.random().toString(36).substring(2, 10);
            }
            
            gameState.rng = new SeededRandom(gameState.seed + '_' + level);
            
            // Update floor material
            floorMaterial.uniforms.level.value = level;
            createWalls(level);
            
            // Generate stars - more on higher levels
            const starCount = 5 + Math.floor(level * 1.5);
            gameState.totalStars = starCount;
            gameState.starsCollected = 0;
            
            // Apply power-up effects to player physics
            if (gameState.activePowerUpEffects.speed) {
                playerPhysics.maxSpeed = 0.25 * gameState.activePowerUpEffects.speed;
            } else {
                playerPhysics.maxSpeed = 0.25;
            }
            
            const starPositions = [];
            for (let i = 0; i < starCount; i++) {
                let x, z, valid;
                let attempts = 0;
                do {
                    valid = true;
                    x = gameState.rng.nextFloat(-arenaWidth/2 + 2, arenaWidth/2 - 2);
                    z = gameState.rng.nextFloat(-arenaHeight/2 + 2, arenaHeight/2 - 2);
                    
                    // Check distance from player spawn
                    if (Math.sqrt(x * x + z * z) < 4) valid = false;
                    
                    // Check distance from other stars
                    for (const pos of starPositions) {
                        const dx = pos.x - x;
                        const dz = pos.z - z;
                        if (Math.sqrt(dx * dx + dz * dz) < 2.5) valid = false;
                    }
                    
                    attempts++;
                } while (!valid && attempts < 100);
                
                if (valid) {
                    starPositions.push({ x, z });
                    createStar(x, z);
                }
            }
            
            // Generate obstacles - more and trickier on higher levels
            const obstacleCount = 2 + Math.floor(level * 1.8);
            const obstaclePositions = [];
            
            for (let i = 0; i < obstacleCount; i++) {
                let x, z, valid;
                let attempts = 0;
                do {
                    valid = true;
                    x = gameState.rng.nextFloat(-arenaWidth/2 + 3, arenaWidth/2 - 3);
                    z = gameState.rng.nextFloat(-arenaHeight/2 + 3, arenaHeight/2 - 3);
                    
                    // Check distance from player spawn
                    if (Math.sqrt(x * x + z * z) < 6) valid = false;
                    
                    // Check distance from stars
                    for (const pos of starPositions) {
                        const dx = pos.x - x;
                        const dz = pos.z - z;
                        if (Math.sqrt(dx * dx + dz * dz) < 3) valid = false;
                    }
                    
                    // Check distance from other obstacles
                    for (const pos of obstaclePositions) {
                        const dx = pos.x - x;
                        const dz = pos.z - z;
                        if (Math.sqrt(dx * dx + dz * dz) < 2.5) valid = false;
                    }
                    
                    attempts++;
                } while (!valid && attempts < 100);
                
                if (valid) {
                    obstaclePositions.push({ x, z });
                    const width = gameState.rng.nextFloat(1, 3.5);
                    const depth = gameState.rng.nextFloat(1, 3.5);
                    // More moving obstacles on higher levels - faster too
                    const isMoving = gameState.rng.next() < (0.5 + level * 0.1);
                    const moveSpeed = gameState.rng.nextFloat(1.2, 2.5 + level * 0.2);
                    const moveRange = gameState.rng.nextFloat(2.5, 5 + level * 0.4);
                    const moveAxis = gameState.rng.next() < 0.5 ? 'x' : 'z';
                    
                    createObstacle(x, z, width, depth, isMoving, moveSpeed, moveRange, moveAxis, level);
                }
            }
            
            // Create primary enemy at random position away from player
            let enemyX, enemyZ;
            const angle = gameState.rng.nextFloat(0, Math.PI * 2);
            const distance = gameState.rng.nextFloat(10, 13);
            enemyX = Math.cos(angle) * distance;
            enemyZ = Math.sin(angle) * distance;
            
            // Keep enemy in bounds
            enemyX = Math.max(-arenaWidth/2 + 2, Math.min(arenaWidth/2 - 2, enemyX));
            enemyZ = Math.max(-arenaHeight/2 + 2, Math.min(arenaHeight/2 - 2, enemyZ));
            
            createEnemy(enemyX, enemyZ, level);
            
            // ADDITIONAL ENEMIES on higher levels!
            // Level 4+: 1 extra enemy
            // Level 7+: 2 extra enemies
            // Level 10+: 3 extra enemies
            const extraEnemyCount = level >= 10 ? 3 : (level >= 7 ? 2 : (level >= 4 ? 1 : 0));
            
            for (let i = 0; i < extraEnemyCount; i++) {
                let exX, exZ;
                const exAngle = gameState.rng.nextFloat(0, Math.PI * 2);
                const exDistance = gameState.rng.nextFloat(8, 12);
                exX = Math.cos(exAngle) * exDistance;
                exZ = Math.sin(exAngle) * exDistance;
                
                // Keep in bounds
                exX = Math.max(-arenaWidth/2 + 2, Math.min(arenaWidth/2 - 2, exX));
                exZ = Math.max(-arenaHeight/2 + 2, Math.min(arenaHeight/2 - 2, exZ));
                
                createAdditionalEnemy(exX, exZ, level, i + 1);
            }
            
            // MOVING WALLS on higher levels (level 5+)
            if (level >= 5) {
                const movingWallCount = Math.min(2, Math.floor((level - 4) / 2));
                for (let i = 0; i < movingWallCount; i++) {
                    const isHorizontal = gameState.rng.next() < 0.5;
                    const wallLength = gameState.rng.nextFloat(3, 6);
                    const wallThickness = 0.8;
                    const moveSpeed = gameState.rng.nextFloat(0.8, 1.5 + level * 0.1);
                    const moveRange = gameState.rng.nextFloat(3, 6);
                    
                    let wx, wz;
                    if (isHorizontal) {
                        wx = gameState.rng.nextFloat(-arenaWidth/2 + 5, arenaWidth/2 - 5);
                        wz = gameState.rng.next() < 0.5 ? -arenaHeight/2 + 3 : arenaHeight/2 - 3;
                    } else {
                        wx = gameState.rng.next() < 0.5 ? -arenaWidth/2 + 3 : arenaWidth/2 - 3;
                        wz = gameState.rng.nextFloat(-arenaHeight/2 + 5, arenaHeight/2 - 5);
                    }
                    
                    createMovingWall(wx, wz, wallLength, wallThickness, isHorizontal, moveSpeed, moveRange, level);
                }
            }
            
            // Reset player position
            playerPhysics.position.set(0, 0, 0);
            playerPhysics.velocity.set(0, 0, 0);
            
            updateHUD();
        }
        
        // Input handling
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // Track Control keys for dash/break
            if (e.key === 'Control') {
                if (e.location === 1) {
                    keys['leftctrl'] = true;
                } else if (e.location === 2) {
                    keys['rightctrl'] = true;
                } else {
                    // Fallback for browsers that don't support location
                    keys['leftctrl'] = true;
                }
            }

            // Track Shift keys for zoom in/out
            if (e.key === 'Shift') {
                if (e.location === 1) {
                    keys['leftshift'] = true;  // L2 equivalent - zoom out
                } else if (e.location === 2) {
                    keys['rightshift'] = true; // R2 equivalent - zoom in
                } else {
                    // Fallback for browsers that don't support location
                    keys['leftshift'] = true;
                }
            }
            
            // Detect keyboard input and update hints
            if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'b'].includes(e.key.toLowerCase())) {
                e.preventDefault();
                
                // Update device detection if keyboard is used
                if (inputDevice.current !== 'keyboard' && !e.repeat) {
                    inputDevice.current = 'keyboard';
                    inputDevice.lastSwitchTime = Date.now();
                    updateInstructionsHint();
                }
            }
            
            // Open shop with 'B' key (pauses game during gameplay, or from level complete)
            if (e.key.toLowerCase() === 'b' && !gameState.isGameOver && document.getElementById('shop-menu').style.display !== 'block') {
                if (gameState.isLevelComplete) {
                    document.getElementById('level-complete').style.display = 'none';
                }
                openShop();
                e.preventDefault();
            }
            
            // Close shop with Escape
            if (e.key === 'Escape' && document.getElementById('shop-menu').style.display === 'block') {
                closeShop();
                // If closed from level complete, show level complete again
                if (gameState.isLevelComplete) {
                    document.getElementById('level-complete').style.display = 'block';
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            
            // Clear Control keys
            if (e.key === 'Control') {
                if (e.location === 1) {
                    keys['leftctrl'] = false;
                } else if (e.location === 2) {
                    keys['rightctrl'] = false;
                } else {
                    keys['leftctrl'] = false;
                }
            }

            // Clear Shift keys
            if (e.key === 'Shift') {
                if (e.location === 1) {
                    keys['leftshift'] = false;
                } else if (e.location === 2) {
                    keys['rightshift'] = false;
                } else {
                    keys['leftshift'] = false;
                }
            }
        });

        // ============================================
        // GAMEPAD SUPPORT (Xbox, DirectInput, etc.)
        // ============================================
        let gamepadIndex = null;
        let gamepadConnected = false;
        let gamepadDeadzone = 0.15; // Deadzone to prevent drift

        // Gamepad connection handlers
        window.addEventListener('gamepadconnected', (e) => {
            console.log('Gamepad connected:', e.gamepad.id);
            gamepadIndex = e.gamepad.index;
            gamepadConnected = true;
            const statusEl = document.getElementById('controller-status');
            statusEl.textContent = `üéÆ ${e.gamepad.id.substring(0, 30)} Connected`;
            statusEl.classList.remove('disconnected');
            statusEl.style.display = 'block';
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log('Gamepad disconnected');
            if (gamepadIndex === e.gamepad.index) {
                gamepadIndex = null;
                gamepadConnected = false;
                const statusEl = document.getElementById('controller-status');
                statusEl.textContent = `üéÆ ${e.gamepad.id.substring(0, 30)} Disconnected`;
                statusEl.classList.add('disconnected');
                statusEl.style.display = 'block';
                
                // Hide disconnected message after 3 seconds
                setTimeout(() => {
                    if (!gamepadConnected) {
                        statusEl.style.display = 'none';
                        statusEl.classList.remove('disconnected');
                    }
                }, 3000);
            }
        });

        // Get gamepad input (call this every frame)
        function getGamepadInput() {
            if (!gamepadConnected || gamepadIndex === null) {
                return { x: 0, y: 0, shopPressed: false, aPressed: false, bPressed: false, startPressed: false, dpadPressed: { x: 0, y: 0 }, r1Pressed: false, l1Pressed: false, r2Pressed: 0, l2Pressed: 0 };
            }

            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];

            if (!gamepad) {
                return { x: 0, y: 0, shopPressed: false, aPressed: false, bPressed: false, startPressed: false, dpadPressed: { x: 0, y: 0 }, r1Pressed: false, l1Pressed: false, r2Pressed: 0, l2Pressed: 0 };
            }

            // Update device detection if gamepad input is detected
            const hasGamepadInput = gamepad.axes.some(axis => Math.abs(axis) > 0.1) ||
                                    gamepad.buttons.some(button => button.pressed);
            if (hasGamepadInput && inputDevice.current !== 'gamepad') {
                inputDevice.current = 'gamepad';
                inputDevice.lastSwitchTime = Date.now();
                updateInstructionsHint();
            }

            // Check if any menu is open
            const shopOpen = document.getElementById('shop-menu').style.display === 'block';
            const gameOverOpen = document.getElementById('game-over').style.display === 'block';
            const levelCompleteOpen = document.getElementById('level-complete').style.display === 'block';
            const menuOpen = shopOpen || gameOverOpen || levelCompleteOpen;

            // Button mappings - with safe checks
            const aButtonIndex = 0;    // A button on Xbox (confirm)
            const bButtonIndex = 1;    // B button on Xbox (cancel/back)
            const startButtonIndex = 9; // Start button
            const selectButtonIndex = 8; // Select button (alternative to Start)
            const l1ButtonIndex = 4;   // L1 / Left Bumper (break)
            const r1ButtonIndex = 5;   // R1 / Right Bumper (dash)

            // Helper function to safely check button
            const isButtonPressed = (index) => {
                return gamepad.buttons[index] && gamepad.buttons[index].pressed;
            };

            let x = 0;
            let y = 0;

            // D-pad (buttons 12-15 on many controllers) - with safe checks
            // Correct mapping for Xbox controllers: 12=Up, 13=Down, 14=Left, 15=Right
            let dpadX = 0, dpadY = 0;
            if (isButtonPressed(14)) dpadX = -1; // D-pad left (button 14)
            if (isButtonPressed(13)) dpadY = 1;  // D-pad down (button 13)
            if (isButtonPressed(15)) dpadX = 1;  // D-pad right (button 15)
            if (isButtonPressed(12)) dpadY = -1; // D-pad up (button 12)

            // During menu navigation, D-pad is only for menus, not movement
            if (menuOpen) {
                // D-pad for menu navigation only - no character movement
                return {
                    x: 0,
                    y: 0,
                    shopPressed: false,
                    aPressed: isButtonPressed(aButtonIndex),
                    bPressed: isButtonPressed(bButtonIndex),
                    startPressed: isButtonPressed(startButtonIndex) || isButtonPressed(selectButtonIndex),
                    dpadPressed: { x: dpadX, y: dpadY },
                    r1Pressed: false,
                    l1Pressed: false,
                    r2Pressed: 0,
                    l2Pressed: 0
                };
            }

            // During gameplay, use ONLY sticks for movement - NO ABXY BUTTONS
            // Left stick (axes 0 and 1)
            if (Math.abs(gamepad.axes[0]) > gamepadDeadzone) {
                x = gamepad.axes[0];
            }
            if (Math.abs(gamepad.axes[1]) > gamepadDeadzone) {
                y = gamepad.axes[1];
            }

            // Right stick as alternative (axes 2 and 3)
            if (x === 0 && y === 0) {
                if (Math.abs(gamepad.axes[2]) > gamepadDeadzone) {
                    x = gamepad.axes[2];
                }
                if (Math.abs(gamepad.axes[3]) > gamepadDeadzone) {
                    y = gamepad.axes[3];
                }
            }

            // D-pad can also be used for movement during gameplay (as alternative)
            if (x === 0 && y === 0) {
                x = dpadX;
                y = dpadY;
            }

            // Get trigger values (R2 and L2) - check both buttons and axes
            // Different controllers expose triggers differently
            let r2Trigger = 0;
            let l2Trigger = 0;

            // Try buttons array first (buttons 6 and 7)
            if (gamepad.buttons[7] && gamepad.buttons[7].value !== undefined) {
                r2Trigger = gamepad.buttons[7].value;
            }
            if (gamepad.buttons[6] && gamepad.buttons[6].value !== undefined) {
                l2Trigger = gamepad.buttons[6].value;
            }

            // Also try axes array (some controllers use axes 4 and 5 for triggers)
            if (r2Trigger === 0 && gamepad.axes.length > 5) {
                r2Trigger = (gamepad.axes[5] + 1) / 2; // Convert from -1..1 to 0..1
            }
            if (l2Trigger === 0 && gamepad.axes.length > 4) {
                l2Trigger = (gamepad.axes[4] + 1) / 2; // Convert from -1..1 to 0..1
            }

            // Normalize to 0-1 range
            r2Trigger = Math.max(0, Math.min(1, r2Trigger));
            l2Trigger = Math.max(0, Math.min(1, l2Trigger));

            return {
                x: Math.max(-1, Math.min(1, x)),
                y: Math.max(-1, Math.min(1, y)),
                shopPressed: isButtonPressed(bButtonIndex),
                aPressed: isButtonPressed(aButtonIndex),
                bPressed: isButtonPressed(bButtonIndex),
                startPressed: isButtonPressed(startButtonIndex) || isButtonPressed(selectButtonIndex),
                dpadPressed: { x: dpadX, y: dpadY },
                r1Pressed: isButtonPressed(r1ButtonIndex),
                l1Pressed: isButtonPressed(l1ButtonIndex),
                r2Pressed: r2Trigger, // R2 trigger value (0-1, analog)
                l2Pressed: l2Trigger  // L2 trigger value (0-1, analog)
            };
        }

        // ============================================
        // CONTROLLER NAVIGATION SYSTEM
        // ============================================
        const navState = {
            currentFocus: null,
            focusableElements: [],
            lastDpadTime: 0,
            dpadCooldown: 200, // ms between dpad movements
            lastAPress: false,
            lastBPress: false,
            lastStartPress: false
        };

        // Update focusable elements based on current screen
        function updateFocusableElements() {
            navState.focusableElements = [];

            // Shop menu
            if (document.getElementById('shop-menu').style.display === 'block') {
                const shopButtons = document.querySelectorAll('#shop-menu .focusable');
                navState.focusableElements = Array.from(shopButtons);
                document.getElementById('shop-nav-hint').style.display = 'block';
            } else {
                document.getElementById('shop-nav-hint').style.display = 'none';
            }

            // Game over screen
            if (document.getElementById('game-over').style.display === 'block') {
                const gameOverButtons = document.querySelectorAll('#game-over .focusable');
                navState.focusableElements = Array.from(gameOverButtons);
                document.getElementById('game-over-nav-hint').style.display = 'block';
            } else {
                document.getElementById('game-over-nav-hint').style.display = 'none';
            }

            // Level complete screen
            if (document.getElementById('level-complete').style.display === 'block') {
                const levelCompleteButtons = document.querySelectorAll('#level-complete .focusable');
                navState.focusableElements = Array.from(levelCompleteButtons);
                document.getElementById('level-complete-nav-hint').style.display = 'block';
            } else {
                document.getElementById('level-complete-nav-hint').style.display = 'none';
            }

            // Set initial focus if needed
            if (navState.focusableElements.length > 0 && !navState.currentFocus) {
                setFocus(0);
            }
        }

        // Set focus to element at index
        function setFocus(index) {
            // Remove focus from current element
            if (navState.currentFocus) {
                navState.currentFocus.classList.remove('controller-focused');
            }

            // Set new focus
            if (index >= 0 && index < navState.focusableElements.length) {
                navState.currentFocus = navState.focusableElements[index];
                navState.currentFocus.classList.add('controller-focused');

                // Scroll into view if needed
                navState.currentFocus.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Handle controller navigation
        function handleControllerNavigation() {
            if (!gamepadConnected || gamepadIndex === null) return;

            const input = getGamepadInput();
            const now = Date.now();

            // Check if any menu is open
            const shopOpen = document.getElementById('shop-menu').style.display === 'block';
            const gameOverOpen = document.getElementById('game-over').style.display === 'block';
            const levelCompleteOpen = document.getElementById('level-complete').style.display === 'block';
            const menuOpen = shopOpen || gameOverOpen || levelCompleteOpen;

            // Handle Start button (like Escape) - toggle shop/pause
            if (input.startPressed && !navState.lastStartPress) {
                // Start button behavior
                if (!gameState.isGameOver) {
                    if (shopOpen) {
                        // Close shop
                        closeShop();
                    } else if (levelCompleteOpen) {
                        // From level complete, open shop
                        document.getElementById('level-complete').style.display = 'none';
                        openShop();
                    } else {
                        // During gameplay, open shop
                        openShop();
                    }
                }
                navState.lastStartPress = true;
            } else if (!input.startPressed) {
                navState.lastStartPress = false;
            }

            if (navState.focusableElements.length === 0) return;
            if (!menuOpen) return;

            // Handle D-pad navigation
            if (input.dpadPressed.x !== 0 || input.dpadPressed.y !== 0) {
                if (now - navState.lastDpadTime > navState.dpadCooldown) {
                    moveFocus(input.dpadPressed.x, input.dpadPressed.y);
                    navState.lastDpadTime = now;
                }
            }

            // Handle stick navigation (for menus) - read directly from gamepad
            // Get gamepad axes directly since input.x/y are 0 during menu mode
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];
            if (gamepad && (input.dpadPressed.x === 0 && input.dpadPressed.y === 0)) {
                const stickX = gamepad.axes[0] || 0; // Left stick X
                const stickY = gamepad.axes[1] || 0; // Left stick Y
                
                // Only process stick input if there's actual movement above deadzone
                if (Math.abs(stickX) > 0.3 || Math.abs(stickY) > 0.3) {
                    if (now - navState.lastDpadTime > navState.dpadCooldown) {
                        const dirX = stickX > 0.3 ? 1 : (stickX < -0.3 ? -1 : 0);
                        const dirY = stickY > 0.3 ? 1 : (stickY < -0.3 ? -1 : 0);
                        if (dirX !== 0 || dirY !== 0) {
                            moveFocus(dirX, dirY);
                            navState.lastDpadTime = now;
                        }
                    }
                }
            }

            // Handle A button (confirm/activate)
            if (input.aPressed && !navState.lastAPress) {
                if (navState.currentFocus) {
                    activateFocusedElement();
                }
                navState.lastAPress = true;
            } else if (!input.aPressed) {
                navState.lastAPress = false;
            }

            // Handle B button (cancel/back)
            if (input.bPressed && !navState.lastBPress) {
                handleBackButton();
                navState.lastBPress = true;
            } else if (!input.bPressed) {
                navState.lastBPress = false;
            }
        }

        // Move focus in direction
        function moveFocus(dirX, dirY) {
            if (!navState.currentFocus) {
                setFocus(0);
                return;
            }

            const currentIndex = navState.focusableElements.indexOf(navState.currentFocus);
            if (currentIndex === -1) {
                setFocus(0);
                return;
            }

            const currentRect = navState.currentFocus.getBoundingClientRect();
            const currentCenterX = currentRect.left + currentRect.width / 2;
            const currentCenterY = currentRect.top + currentRect.height / 2;

            let bestCandidate = null;
            let bestScore = -Infinity;

            // Find best candidate in direction
            navState.focusableElements.forEach((element, index) => {
                if (index === currentIndex) return;

                const rect = element.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                const dx = centerX - currentCenterX;
                const dy = centerY - currentCenterY;

                // Check if element is in the desired direction
                const inDirection = (dirX === 0 || Math.sign(dx) === dirX || (dirX !== 0 && dx * dirX > 0)) &&
                                   (dirY === 0 || Math.sign(dy) === dirY || (dirY !== 0 && dy * dirY > 0));

                if (inDirection) {
                    // Calculate score: prioritize elements in direction, closer distance
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const directionAlignment = (dirX !== 0 ? Math.abs(dx) * dirX : 0) + (dirY !== 0 ? Math.abs(dy) * dirY : 0);
                    const score = directionAlignment - distance * 0.01;

                    if (score > bestScore) {
                        bestScore = score;
                        bestCandidate = index;
                    }
                }
            });

            // If no candidate found in direction, try adjacent element
            if (bestCandidate === null) {
                if (dirX > 0 || dirY > 0) {
                    bestCandidate = (currentIndex + 1) % navState.focusableElements.length;
                } else if (dirX < 0 || dirY < 0) {
                    bestCandidate = (currentIndex - 1 + navState.focusableElements.length) % navState.focusableElements.length;
                }
            }

            if (bestCandidate !== null) {
                setFocus(bestCandidate);
            }
        }

        // Activate the currently focused element
        function activateFocusedElement() {
            if (!navState.currentFocus) return;

            // Handle different element types
            if (navState.currentFocus.tagName === 'BUTTON') {
                navState.currentFocus.click();
            } else if (navState.currentFocus.tagName === 'INPUT') {
                navState.currentFocus.focus();
            }
        }

        // Handle back button (B)
        function handleBackButton() {
            // Close shop if open
            if (document.getElementById('shop-menu').style.display === 'block') {
                closeShop();
                return;
            }
        }

        // Clean up focus when menus close
        function clearFocus() {
            if (navState.currentFocus) {
                navState.currentFocus.classList.remove('controller-focused');
                navState.currentFocus = null;
            }
            navState.focusableElements = [];
        }

        // ============================================
        // INPUT DEVICE DETECTION & DYNAMIC HINTS
        // ============================================
        const inputDevice = {
            current: 'keyboard', // 'keyboard', 'gamepad', 'touch'
            lastActive: Date.now(),
            switchCooldown: 1000, // ms before allowing device switch
            lastSwitchTime: 0
        };

        // Device-specific hint texts
        const deviceHints = {
            keyboard: '<span class="controller-icon keyboard-icon"></span> WASD/Arrows to move ‚Ä¢ R-Ctrl: Dash ‚Ä¢ L-Ctrl: Break ‚Ä¢ R-Shift: Zoom In ‚Ä¢ L-Shift: Zoom Out ‚Ä¢ B for Shop',
            gamepad: '<span class="controller-icon xbox-icon"></span> Left Stick/D-pad to move ‚Ä¢ R1: Dash ‚Ä¢ L1: Break ‚Ä¢ R2: Zoom In ‚Ä¢ L2: Zoom Out ‚Ä¢ B/Start for Shop',
            touch: '<span class="controller-icon touch-icon"></span> Drag joystick to move ‚Ä¢ Tap üõí for Shop'
        };

        // Detect which input device is currently being used
        function detectInputDevice() {
            const now = Date.now();
            
            // Don't switch devices too frequently
            if (now - inputDevice.lastSwitchTime < inputDevice.switchCooldown) {
                return inputDevice.current;
            }

            let newDevice = inputDevice.current;

            // Check for touch input (highest priority on mobile)
            if (touchControls.active && (Math.abs(touchControls.joystickX) > 0.1 || Math.abs(touchControls.joystickY) > 0.1 || touchControls.shopPressed)) {
                newDevice = 'touch';
            }
            // Check for gamepad input
            else if (gamepadConnected) {
                const gamepadInput = getGamepadInput();
                if (Math.abs(gamepadInput.x) > 0.1 || Math.abs(gamepadInput.y) > 0.1 || gamepadInput.shopPressed || gamepadInput.aPressed || gamepadInput.bPressed) {
                    newDevice = 'gamepad';
                }
            }
            // Check for keyboard input
            else {
                const hasKeyboardInput = keys['w'] || keys['a'] || keys['s'] || keys['d'] || 
                                         keys['arrowup'] || keys['arrowleft'] || keys['arrowdown'] || keys['arrowright'];
                if (hasKeyboardInput) {
                    newDevice = 'keyboard';
                }
            }

            // Update device if changed
            if (newDevice !== inputDevice.current) {
                inputDevice.current = newDevice;
                inputDevice.lastSwitchTime = now;
                updateInstructionsHint();
            }

            return inputDevice.current;
        }

        // Update the instructions hint based on current device
        function updateInstructionsHint() {
            const instructions = document.getElementById('instructions');
            if (instructions && deviceHints[inputDevice.current]) {
                instructions.innerHTML = deviceHints[inputDevice.current];
            }
        }

        // Initialize hints on load
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial device based on what's available
            if (isTouchDevice()) {
                inputDevice.current = 'touch';
            } else if (gamepadConnected) {
                inputDevice.current = 'gamepad';
            } else {
                inputDevice.current = 'keyboard';
            }
            updateInstructionsHint();
        });

        // Update hints when gamepad connects/disconnects
        window.addEventListener('gamepadconnected', () => {
            inputDevice.current = 'gamepad';
            updateInstructionsHint();
        });

        window.addEventListener('gamepaddisconnected', () => {
            inputDevice.current = 'keyboard';
            updateInstructionsHint();
        });

        // ============================================
        // TOUCH/VIRTUAL JOYSTICK SUPPORT (Mobile)
        // ============================================
        let touchControls = {
            active: false,
            joystickX: 0,
            joystickY: 0,
            shopPressed: false
        };

        const joystick = document.getElementById('virtual-joystick');
        const joystickHandle = document.getElementById('joystick-handle');
        const joystickRadius = 35; // Maximum handle movement radius

        // Detect touch device
        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        }

        // Initialize touch controls if on mobile
        if (isTouchDevice()) {
            document.getElementById('touch-controls').style.display = 'block';
            document.getElementById('touch-buttons').style.display = 'block';
            touchControls.active = true;
        }

        // Virtual joystick touch handlers
        let joystickTouchId = null;
        let joystickCenter = { x: 0, y: 0 };

        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joystickTouchId = touch.identifier;

            const rect = joystick.getBoundingClientRect();
            joystickCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };

            updateJoystick(touch.clientX, touch.clientY);
            
            // Update device detection for touch input
            if (inputDevice.current !== 'touch') {
                inputDevice.current = 'touch';
                inputDevice.lastSwitchTime = Date.now();
                updateInstructionsHint();
            }
        }, { passive: false });

        joystick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                if (touch.identifier === joystickTouchId) {
                    updateJoystick(touch.clientX, touch.clientY);
                    break;
                }
            }
        }, { passive: false });

        joystick.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                if (touch.identifier === joystickTouchId) {
                    joystickTouchId = null;
                    resetJoystick();
                    break;
                }
            }
        }, { passive: false });

        joystick.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            joystickTouchId = null;
            resetJoystick();
        }, { passive: false });

        function updateJoystick(clientX, clientY) {
            const dx = clientX - joystickCenter.x;
            const dy = clientY - joystickCenter.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Normalize and clamp
            const clampedDistance = Math.min(distance, joystickRadius);
            const angle = Math.atan2(dy, dx);

            const handleX = Math.cos(angle) * clampedDistance;
            const handleY = Math.sin(angle) * clampedDistance;

            // Update visual position
            joystickHandle.style.transform = `translate(calc(-50% + ${handleX}px), calc(-50% + ${handleY}px))`;

            // Normalize input to -1 to 1 range
            touchControls.joystickX = handleX / joystickRadius;
            touchControls.joystickY = handleY / joystickRadius;
        }

        function resetJoystick() {
            joystickHandle.style.transform = 'translate(-50%, -50%)';
            touchControls.joystickX = 0;
            touchControls.joystickY = 0;
        }

        // Touch button handlers
        const shopBtn = document.getElementById('touch-shop-btn');

        shopBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchControls.shopPressed = true;
            
            // Update device detection for touch input
            if (inputDevice.current !== 'touch') {
                inputDevice.current = 'touch';
                inputDevice.lastSwitchTime = Date.now();
                updateInstructionsHint();
            }
            
            if (!gameState.isGameOver && document.getElementById('shop-menu').style.display !== 'block') {
                if (gameState.isLevelComplete) {
                    document.getElementById('level-complete').style.display = 'none';
                }
                openShop();
            }
        }, { passive: false });

        shopBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchControls.shopPressed = false;
        }, { passive: false });

        shopBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            touchControls.shopPressed = false;
        }, { passive: false });

        // ============================================
        // UNIFIED INPUT HANDLING
        // ============================================
        function getInput() {
            let x = 0, y = 0;
            let dashPressed = false;
            let breakPressed = false;
            let zoomInPressed = false;
            let zoomOutPressed = false;

            // Keyboard input
            if (keys['w'] || keys['arrowup']) y -= 1;
            if (keys['s'] || keys['arrowdown']) y += 1;
            if (keys['a'] || keys['arrowleft']) x -= 1;
            if (keys['d'] || keys['arrowright']) x += 1;

            // Keyboard dash/break/zoom
            if (keys['rightctrl']) dashPressed = true;
            if (keys['leftctrl']) breakPressed = true;
            if (keys['rightshift']) zoomInPressed = true;  // R2 equivalent - zoom in
            if (keys['leftshift']) zoomOutPressed = true;  // L2 equivalent - zoom out

            // Gamepad input (overrides keyboard if active)
            const gamepadInput = getGamepadInput();
            if (gamepadInput.x !== 0 || gamepadInput.y !== 0) {
                x = gamepadInput.x;
                y = gamepadInput.y;
            }
            if (gamepadInput.r1Pressed) dashPressed = true;
            if (gamepadInput.l1Pressed) breakPressed = true;
            // R2/L2 are analog triggers - pass through raw values, handle threshold in zoom logic

            // Touch/virtual joystick input (highest priority)
            if (touchControls.active && (touchControls.joystickX !== 0 || touchControls.joystickY !== 0)) {
                x = touchControls.joystickX;
                y = touchControls.joystickY;
            }

            return { x, y, dashPressed, breakPressed, zoomInPressed, zoomOutPressed, r2Value: gamepadInput.r2Pressed, l2Value: gamepadInput.l2Pressed };
        }

        // Collision detection
        function checkCollision(pos1, radius1, pos2, width, depth) {
            const halfW = width / 2 + radius1;
            const halfD = depth / 2 + radius1;
            
            return Math.abs(pos1.x - pos2.x) < halfW && 
                   Math.abs(pos1.z - pos2.z) < halfD;
        }
        
        function checkCircleCollision(pos1, radius1, pos2, radius2) {
            const dx = pos1.x - pos2.x;
            const dz = pos1.z - pos2.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            return dist < radius1 + radius2;
        }
        
        // Update HUD
        function updateHUD() {
            document.getElementById('score-value').textContent = gameState.score;
            document.getElementById('stars-value').textContent = `${gameState.starsCollected}/${gameState.totalStars}`;
            document.getElementById('lives-value').textContent = gameState.lives;
            document.getElementById('level-value').textContent = gameState.level;
            document.getElementById('seed-value').textContent = gameState.seed || 'Random';
            document.getElementById('coins-value').textContent = playerProgress.coins;
            
            // Update active power-ups display
            const powerUpsDisplay = document.getElementById('power-ups-display');
            if (playerProgress.activePowerUps.length > 0) {
                powerUpsDisplay.innerHTML = 'Active: ' + playerProgress.activePowerUps.map(id => {
                    const powerUp = POWER_UPS[id];
                    const level = playerProgress.powerUps[id];
                    return `<span class="power-up-slot" title="${powerUp.description}">${powerUp.icon} Lv.${level}</span>`;
                }).join('');
            } else {
                powerUpsDisplay.innerHTML = '';
            }
        }

        // Shop UI Functions
        function updateShopUI() {
            document.getElementById('shop-coins-value').textContent = playerProgress.coins;
            document.getElementById('active-slots-count').textContent = playerProgress.activePowerUps.length;
            document.getElementById('max-slots-count').textContent = playerProgress.maxPowerUpSlots;

            const availableContainer = document.getElementById('available-power-ups');
            const ownedContainer = document.getElementById('owned-power-ups');

            availableContainer.innerHTML = '';
            ownedContainer.innerHTML = '';

            Object.keys(POWER_UPS).forEach(powerUpId => {
                const powerUp = POWER_UPS[powerUpId];
                const level = getPowerUpLevel(powerUpId);
                const isEquipped = playerProgress.activePowerUps.includes(powerUpId);
                const isOwned = level > 0;

                const item = document.createElement('div');
                item.className = 'power-up-item focusable';
                if (isOwned) item.classList.add('owned');
                if (isEquipped) item.classList.add('equipped');

                let actionButtons = '';
                let levelInfo = '';

                if (isOwned) {
                    levelInfo = `<div class="power-up-level">Level: ${level} / ${powerUp.maxLevel}</div>`;

                    if (isEquipped) {
                        actionButtons = `<button class="shop-btn unequip focusable" onclick="unequipPowerUp('${powerUpId}')">Unequip</button>`;
                    } else {
                        actionButtons = `<button class="shop-btn equip focusable" onclick="equipPowerUp('${powerUpId}')" ${playerProgress.activePowerUps.length >= playerProgress.maxPowerUpSlots ? 'disabled' : ''}>Equip</button>`;
                    }

                    if (level < powerUp.maxLevel) {
                        const cost = getPowerUpCost(powerUpId, level);
                        actionButtons += `<button class="shop-btn focusable" onclick="purchasePowerUp('${powerUpId}')" ${playerProgress.coins < cost ? 'disabled' : ''}>Upgrade (${cost} üí∞)</button>`;
                    } else {
                        actionButtons += `<span style="color: #88ddff; font-size: 14px;">MAX LEVEL</span>`;
                    }
                } else {
                    const cost = getPowerUpCost(powerUpId, 0);
                    actionButtons = `<button class="shop-btn focusable" onclick="purchasePowerUp('${powerUpId}')" ${playerProgress.coins < cost ? 'disabled' : ''}>Buy (${cost} üí∞)</button>`;
                }

                item.innerHTML = `
                    <div class="power-up-header">
                        <span class="power-up-name">${powerUp.icon} ${powerUp.name}</span>
                    </div>
                    <div class="power-up-description">${powerUp.description}</div>
                    ${levelInfo}
                    <div class="power-up-actions">
                        ${actionButtons}
                    </div>
                `;

                if (isOwned) {
                    ownedContainer.appendChild(item);
                } else {
                    availableContainer.appendChild(item);
                }
            });
        }

        function openShop() {
            updateShopUI();
            document.getElementById('shop-menu').style.display = 'block';
            clearFocus();
            updateFocusableElements();
        }

        function closeShop() {
            document.getElementById('shop-menu').style.display = 'none';
            document.getElementById('pause-indicator').style.display = 'none';
            clearFocus();
            updateFocusableElements();

            // If closed from level complete, show level complete again
            if (gameState.isLevelComplete) {
                document.getElementById('level-complete').style.display = 'block';
                updateFocusableElements();
            }
        }

        // Make functions globally available
        window.purchasePowerUp = purchasePowerUp;
        window.equipPowerUp = equipPowerUp;
        window.unequipPowerUp = unequipPowerUp;
        window.openShop = openShop;
        window.closeShop = closeShop;
        
        // Copy seed to clipboard
        function copySeed() {
            const seed = gameState.seed;
            navigator.clipboard.writeText(seed).then(() => {
                const toast = document.getElementById('seed-toast');
                toast.style.display = 'block';
                setTimeout(() => toast.style.display = 'none', 2000);
            });
        }
        
        // Show game over
        function showGameOver() {
            gameState.isGameOver = true;
            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('final-level').textContent = gameState.level;
            document.getElementById('game-over').style.display = 'block';
            clearFocus();
            updateFocusableElements();
        }

        // Show level complete
        function showLevelComplete() {
            gameState.levelCompletionTime = (Date.now() - gameState.levelStartTime) / 1000;
            gameState.coinsEarned = calculateCoinsReward(gameState.level, gameState.levelCompletionTime);

            playerProgress.coins += gameState.coinsEarned;
            playerProgress.totalLevelsCompleted++;

            // Update high score if needed
            const levelKey = `level_${gameState.level}`;
            if (!playerProgress.highScores[levelKey] || gameState.score > playerProgress.highScores[levelKey]) {
                playerProgress.highScores[levelKey] = gameState.score;
            }

            saveProgress();

            gameState.isLevelComplete = true;
            document.getElementById('level-score').textContent = gameState.score;
            document.getElementById('level-time').textContent = gameState.levelCompletionTime.toFixed(1);
            document.getElementById('level-coins').textContent = gameState.coinsEarned;
            document.getElementById('level-complete').style.display = 'block';
            clearFocus();
            updateFocusableElements();
            updateHUD();
        }

        // Restart game
        function restartGame(newSeed = null) {
            loadProgress();
            applyPowerUpEffects();

            gameState.score = 0;
            gameState.lives = 3 + (gameState.activePowerUpEffects.extraLives || 0);
            gameState.level = 1;
            gameState.isGameOver = false;
            gameState.isLevelComplete = false;
            gameState.seed = newSeed;
            gameState.coinsEarned = 0;

            document.getElementById('game-over').style.display = 'none';
            document.getElementById('level-complete').style.display = 'none';
            document.getElementById('seed-input').value = '';
            clearFocus();
            updateFocusableElements();

            generateLevel(1);
        }

        // Next level
        function nextLevel() {
            gameState.level++;
            gameState.isLevelComplete = false;
            gameState.coinsEarned = 0;
            gameState.lives = 3 + (gameState.activePowerUpEffects.extraLives || 0);

            applyPowerUpEffects();

            document.getElementById('level-complete').style.display = 'none';
            clearFocus();
            updateFocusableElements();

            generateLevel(gameState.level);
        }
        
        // Play specific seed
        function playSeed() {
            const seedInput = document.getElementById('seed-input').value.trim();
            if (seedInput) {
                restartGame(seedInput);
            }
        }
        
        // Restart current stage (same level, same seed)
        function restartStage() {
            const currentLevel = gameState.level;
            const currentSeed = gameState.seed;
            
            // Reset game state but keep level and seed
            gameState.score = 0;
            gameState.lives = 3 + (gameState.activePowerUpEffects.extraLives || 0);
            gameState.isGameOver = false;
            gameState.isLevelComplete = false;
            gameState.coinsEarned = 0;
            
            applyPowerUpEffects();
            
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('level-complete').style.display = 'none';
            document.getElementById('seed-input').value = '';
            
            // Regenerate level with same seed
            generateLevel(currentLevel, currentSeed);
        }
        
        // Button handlers
        document.getElementById('restart-btn').addEventListener('click', () => restartGame(null));
        document.getElementById('restart-stage-btn').addEventListener('click', restartStage);
        document.getElementById('next-level-btn').addEventListener('click', nextLevel);
        document.getElementById('play-seed-btn').addEventListener('click', playSeed);
        document.getElementById('seed-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') playSeed();
        });
        
        // Shop button handlers
        document.getElementById('close-shop-btn').addEventListener('click', closeShop);
        document.getElementById('shop-btn-complete').addEventListener('click', () => {
            document.getElementById('level-complete').style.display = 'none';
            openShop();
        });
        document.getElementById('reset-progress-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to reset all progress? This cannot be undone!')) {
                resetProgress();
            }
        });

        // Add keyboard navigation support
        document.addEventListener('keydown', (e) => {
            // Check if any menu is open for arrow key navigation
            const shopOpen = document.getElementById('shop-menu').style.display === 'block';
            const gameOverOpen = document.getElementById('game-over').style.display === 'block';
            const levelCompleteOpen = document.getElementById('level-complete').style.display === 'block';
            const menuOpen = shopOpen || gameOverOpen || levelCompleteOpen;
            
            // Arrow key navigation for menus
            if (menuOpen && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                const now = Date.now();
                if (now - navState.lastDpadTime > navState.dpadCooldown) {
                    let dirX = 0, dirY = 0;
                    switch(e.key) {
                        case 'ArrowUp': dirY = -1; break;
                        case 'ArrowDown': dirY = 1; break;
                        case 'ArrowLeft': dirX = -1; break;
                        case 'ArrowRight': dirX = 1; break;
                    }
                    moveFocus(dirX, dirY);
                    navState.lastDpadTime = now;
                }
            }
            
            if (e.key === 'Tab') {
                e.preventDefault();
                // Navigate through focusable elements
                if (navState.focusableElements.length > 0) {
                    const currentIndex = navState.currentFocus ? navState.focusableElements.indexOf(navState.currentFocus) : -1;
                    const direction = e.shiftKey ? -1 : 1;
                    const nextIndex = (currentIndex + direction + navState.focusableElements.length) % navState.focusableElements.length;
                    setFocus(nextIndex);
                }
            }

            if (e.key === 'Enter' && navState.currentFocus) {
                activateFocusedElement();
                e.preventDefault();
            }

            if (e.key === 'Escape') {
                handleBackButton();
            }
        });
        
        // Animation loop
        let time = 0;
        let invincibilityTime = 0;
        let shieldActive = false;
        let shieldTimeRemaining = 0;

        // Track previous button states for one-time activation detection
        let prevDashPressed = false;
        let prevBreakPressed = false;

        // Camera zoom state
        const cameraZoom = {
            currentHeight: 25,      // Current Y position (height)
            targetHeight: 25,       // Target Y position
            minHeight: 15,          // Closest zoom (highest)
            maxHeight: 35,          // Farthest zoom (lowest)
            zoomSpeed: 0.15,        // Easing speed for zoom transitions (faster)
            defaultHeight: 25       // Default camera height
        };
        
        function animate() {
            requestAnimationFrame(animate);

            // Detect current input device and update hints
            detectInputDevice();

            // Handle controller navigation for menus
            handleControllerNavigation();

            // Check if shop is open - pause game
            if (document.getElementById('shop-menu').style.display === 'block') {
                document.getElementById('pause-indicator').style.display = 'block';
                renderer.render(scene, camera);
                return;
            } else {
                document.getElementById('pause-indicator').style.display = 'none';
            }

            if (gameState.isGameOver || gameState.isLevelComplete) {
                renderer.render(scene, camera);
                return;
            }
            
            time += 0.016;
            invincibilityTime = Math.max(0, invincibilityTime - 0.016);
            shieldTimeRemaining = Math.max(0, shieldTimeRemaining - 0.016);
            shieldActive = shieldTimeRemaining > 0;
            
            // Update shield indicator
            const shieldIndicator = document.getElementById('shield-indicator');
            if (shieldActive) {
                shieldIndicator.style.display = 'block';
                document.getElementById('shield-time').textContent = shieldTimeRemaining.toFixed(1);
            } else {
                shieldIndicator.style.display = 'none';
            }
            
            // Update dash indicator
            const dashStatus = document.getElementById('dash-status');
            if (playerPhysics.dashActive) {
                dashStatus.textContent = 'ACTIVE!';
                dashStatus.style.color = 'rgba(255, 255, 100, 1)';
            } else if (playerPhysics.dashCooldownRemaining > 0) {
                dashStatus.textContent = playerPhysics.dashCooldownRemaining.toFixed(1) + 's';
                dashStatus.style.color = 'rgba(255, 100, 100, 0.9)';
            } else {
                dashStatus.textContent = 'READY';
                dashStatus.style.color = 'rgba(100, 255, 100, 0.9)';
            }
            
            // Update break indicator
            const breakStatus = document.getElementById('break-status');
            if (playerPhysics.handbrakeActive) {
                breakStatus.textContent = 'ACTIVE!';
                breakStatus.style.color = 'rgba(255, 150, 50, 1)';
            } else if (playerPhysics.handbrakeCooldownRemaining > 0) {
                breakStatus.textContent = playerPhysics.handbrakeCooldownRemaining.toFixed(1) + 's';
                breakStatus.style.color = 'rgba(255, 100, 100, 0.9)';
            } else {
                breakStatus.textContent = 'READY';
                breakStatus.style.color = 'rgba(100, 255, 100, 0.9)';
            }
            
            // Update shader uniforms
            sphereMaterial.uniforms.time.value = time;
            glowMaterial.uniforms.time.value = time;
            floorMaterial.uniforms.time.value = time;

            // Update shooting star trail - multiple segments following behind player
            dashTrailSegments.forEach((segment, index) => {
                segment.visible = playerPhysics.dashActive;
                segment.material.uniforms.time.value = time;

                if (playerPhysics.dashActive) {
                    // Calculate opposite direction of movement
                    const speed = Math.sqrt(playerPhysics.velocity.x ** 2 + playerPhysics.velocity.z ** 2);
                    if (speed > 0.01) {
                        // Each segment is positioned further behind
                        const baseDistance = 1.2; // Distance from player to first segment
                        const segmentSpacing = 0.4; // Distance between segments
                        const trailDistance = baseDistance + (index * segmentSpacing);

                        const trailX = playerPhysics.position.x - (playerPhysics.velocity.x / speed) * trailDistance;
                        const trailZ = playerPhysics.position.z - (playerPhysics.velocity.z / speed) * trailDistance;

                        segment.position.set(trailX, 0, trailZ);
                    } else {
                        // If not moving, segments cluster at player position
                        segment.position.copy(playerPhysics.position);
                    }
                }
            });

            // Update break shield indicator - appears in front of player in direction of movement
            if (breakShield) {
                breakShield.visible = playerPhysics.handbrakeActive;
                breakShield.material.uniforms.time.value = time;

                if (playerPhysics.handbrakeActive) {
                    const speed = Math.sqrt(playerPhysics.velocity.x ** 2 + playerPhysics.velocity.z ** 2);
                    if (speed > 0.01) {
                        // Shield is positioned 1.5 units in front of player in direction of movement
                        const shieldDistance = 1.5;
                        const shieldX = playerPhysics.position.x + (playerPhysics.velocity.x / speed) * shieldDistance;
                        const shieldZ = playerPhysics.position.z + (playerPhysics.velocity.z / speed) * shieldDistance;

                        breakShield.position.set(shieldX, 0, shieldZ);

                        // Rotate shield to face movement direction
                        const angle = Math.atan2(playerPhysics.velocity.x, playerPhysics.velocity.z);
                        breakShield.rotation.y = -angle; // Negative because CircleGeometry faces +Z
                    } else {
                        // If not moving, shield is at player position
                        breakShield.position.copy(playerPhysics.position);
                    }
                }
            }
            walls.forEach(wall => {
                wall.material.uniforms.time.value = time;
            });
            obstacles.forEach(obs => {
                obs.material.uniforms.time.value = time;
                obs.material.uniforms.level.value = gameState.level;
            });
            if (enemy) {
                enemy.children.forEach(child => {
                    if (child.material.uniforms && child.material.uniforms.time) {
                        child.material.uniforms.time.value = time;
                    }
                    if (child.material.uniforms && child.material.uniforms.level) {
                        child.material.uniforms.level.value = gameState.level;
                    }
                });
            }
            
            // Update additional enemy shader uniforms
            enemies.forEach(additionalEnemy => {
                additionalEnemy.children.forEach(child => {
                    if (child.material.uniforms && child.material.uniforms.time) {
                        child.material.uniforms.time.value = time;
                    }
                    if (child.material.uniforms && child.material.uniforms.level) {
                        child.material.uniforms.level.value = gameState.level;
                    }
                });
            });
            
            // Update moving wall shader uniforms and animate them
            movingWalls.forEach((wall, index) => {
                if (wall.material.uniforms && wall.material.uniforms.time) {
                    wall.material.uniforms.time.value = time;
                }
                if (wall.material.uniforms && wall.material.uniforms.level) {
                    wall.material.uniforms.level.value = gameState.level;
                }
                
                const wallData = movingWallsData[index];
                if (wallData) {
                    const offset = Math.sin(time * wallData.moveSpeed) * wallData.moveRange;
                    if (wallData.isHorizontal) {
                        wall.position.x = wallData.baseX + offset;
                    } else {
                        wall.position.z = wallData.baseZ + offset;
                    }
                }
            });
            
            // Handle input - MORE INERTIA FEEL
            // Use unified input system (keyboard + gamepad + touch)
            const input = getInput();
            let inputX = input.x;
            let inputZ = input.y;
            const dashPressed = input.dashPressed;
            const breakPressed = input.breakPressed;
            const zoomInPressed = input.zoomInPressed;
            const zoomOutPressed = input.zoomOutPressed;
            const r2Value = input.r2Value || 0;
            const l2Value = input.l2Value || 0;

            // Update dash cooldown
            playerPhysics.dashCooldownRemaining = Math.max(0, playerPhysics.dashCooldownRemaining - 0.016);
            
            // Update dash active timer
            playerPhysics.dashTimeRemaining = Math.max(0, playerPhysics.dashTimeRemaining - 0.016);
            playerPhysics.dashActive = playerPhysics.dashTimeRemaining > 0;

            // Handle dash activation (R1 or Right Ctrl) - one-time trigger on button press
            if (dashPressed && !prevDashPressed && !playerPhysics.dashActive && playerPhysics.dashCooldownRemaining <= 0) {
                playerPhysics.dashActive = true;
                playerPhysics.dashTimeRemaining = playerPhysics.dashDuration;
                playerPhysics.dashCooldownRemaining = playerPhysics.dashCooldown;
            }

            // Update break cooldown and active timer
            playerPhysics.handbrakeCooldownRemaining = Math.max(0, playerPhysics.handbrakeCooldownRemaining - 0.016);
            playerPhysics.handbrakeTimeRemaining = Math.max(0, playerPhysics.handbrakeTimeRemaining - 0.016);
            playerPhysics.handbrakeActive = playerPhysics.handbrakeTimeRemaining > 0;

            // Handle handbrake activation (L1 or Left Ctrl) - one-time trigger on button press
            if (breakPressed && !prevBreakPressed && !playerPhysics.handbrakeActive && playerPhysics.handbrakeCooldownRemaining <= 0) {
                playerPhysics.handbrakeActive = true;
                playerPhysics.handbrakeTimeRemaining = playerPhysics.handbrakeDuration;
                playerPhysics.handbrakeCooldownRemaining = playerPhysics.dashCooldown; // Same cooldown as dash
            }

            // Store current button states for next frame
            prevDashPressed = dashPressed;
            prevBreakPressed = breakPressed;

            // Handle camera zoom with easing - follows trigger pressure directly
            // R2 / Right Shift: Zoom in (lower height = closer camera)
            // L2 / Left Shift: Zoom out (higher height = farther camera)

            // Calculate zoom target based on trigger values
            // If R2 is pressed (even partially), zoom in proportionally
            // If L2 is pressed (even partially), zoom out proportionally
            // If neither is pressed, return to default
            const hasZoomInput = r2Value > 0.01 || l2Value > 0.01 || zoomInPressed || zoomOutPressed;

            if (r2Value > 0.01) {
                // R2 pressed - zoom in based on trigger pressure (0-1)
                cameraZoom.targetHeight = cameraZoom.defaultHeight - (r2Value * (cameraZoom.defaultHeight - cameraZoom.minHeight));
            } else if (l2Value > 0.01) {
                // L2 pressed - zoom out based on trigger pressure (0-1)
                cameraZoom.targetHeight = cameraZoom.defaultHeight + (l2Value * (cameraZoom.maxHeight - cameraZoom.defaultHeight));
            } else if (zoomInPressed) {
                // Keyboard zoom in (Right Shift) - full zoom
                cameraZoom.targetHeight = cameraZoom.minHeight;
            } else if (zoomOutPressed) {
                // Keyboard zoom out (Left Shift) - full zoom
                cameraZoom.targetHeight = cameraZoom.maxHeight;
            } else {
                // No zoom input - return to default
                cameraZoom.targetHeight = cameraZoom.defaultHeight;
            }

            // Smoothly interpolate current height toward target (easing)
            cameraZoom.currentHeight += (cameraZoom.targetHeight - cameraZoom.currentHeight) * cameraZoom.zoomSpeed;

            // Normalize diagonal input
            if (inputX !== 0 && inputZ !== 0) {
                inputX *= 0.707;
                inputZ *= 0.707;
            }
            
            // Calculate effective acceleration based on dash/break state
            let effectiveAccel = playerPhysics.acceleration;
            let effectiveMaxSpeed = playerPhysics.maxSpeed;
            
            if (playerPhysics.dashActive) {
                // Dash: boost to max speed + 10%
                effectiveMaxSpeed = playerPhysics.maxSpeed * playerPhysics.dashSpeedBoost;
            }
            
            // Apply acceleration - with dash modifier
            playerPhysics.velocity.x += inputX * effectiveAccel * 0.1;
            playerPhysics.velocity.z += inputZ * effectiveAccel * 0.1;
            
            // Apply friction - normal or handbrake
            if (playerPhysics.handbrakeActive) {
                // Handbrake: low friction for drift (maintains speed, allows sliding)
                playerPhysics.velocity.x *= playerPhysics.handbrakeFriction;
                playerPhysics.velocity.z *= playerPhysics.handbrakeFriction;
            } else {
                // Normal friction
                playerPhysics.velocity.x *= playerPhysics.friction;
                playerPhysics.velocity.z *= playerPhysics.friction;
            }
            
            // Clamp speed
            const speed = Math.sqrt(playerPhysics.velocity.x ** 2 + playerPhysics.velocity.z ** 2);
            if (speed > effectiveMaxSpeed) {
                playerPhysics.velocity.x *= effectiveMaxSpeed / speed;
                playerPhysics.velocity.z *= effectiveMaxSpeed / speed;
            }
            
            // Update position
            playerPhysics.position.x += playerPhysics.velocity.x;
            playerPhysics.position.z += playerPhysics.velocity.z;
            
            // Boundary collision
            const halfWidth = arenaWidth / 2 - playerPhysics.radius;
            const halfHeight = arenaHeight / 2 - playerPhysics.radius;
            
            if (playerPhysics.position.x < -halfWidth) {
                playerPhysics.position.x = -halfWidth;
                playerPhysics.velocity.x *= -0.3;
            }
            if (playerPhysics.position.x > halfWidth) {
                playerPhysics.position.x = halfWidth;
                playerPhysics.velocity.x *= -0.3;
            }
            if (playerPhysics.position.z < -halfHeight) {
                playerPhysics.position.z = -halfHeight;
                playerPhysics.velocity.z *= -0.3;
            }
            if (playerPhysics.position.z > halfHeight) {
                playerPhysics.position.z = halfHeight;
                playerPhysics.velocity.z *= -0.3;
            }
            
            // Update player position
            player.position.copy(playerPhysics.position);
            
            // Rotate player based on movement
            if (speed > 0.01) {
                const angle = Math.atan2(playerPhysics.velocity.x, playerPhysics.velocity.z);
                player.rotation.y = angle;
                playerGlow.rotation.y = angle;
            }
            
            // Animate stars
            stars.forEach(star => {
                if (!star.userData.collected) {
                    star.rotation.y += star.userData.rotationSpeed * 0.02;
                    star.position.y = star.userData.baseY + Math.sin(time * 3 + star.position.x) * 0.2;
                    
                    // Check collection with magnet effect
                    const dx = playerPhysics.position.x - star.position.x;
                    const dz = playerPhysics.position.z - star.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    const collectRange = playerPhysics.radius + 0.5 + (gameState.activePowerUpEffects.magnetRange || 0);
                    
                    if (dist < collectRange) {
                        // Magnet effect: pull star toward player
                        if (dist > playerPhysics.radius + 0.5 && gameState.activePowerUpEffects.magnetRange) {
                            const pullSpeed = 0.3;
                            star.position.x += (dx / dist) * pullSpeed;
                            star.position.z += (dz / dist) * pullSpeed;
                        }
                        
                        if (dist < playerPhysics.radius + 0.5) {
                            star.userData.collected = true;
                            star.visible = false;
                            gameState.starsCollected++;
                            
                            // Apply score multiplier power-up
                            let baseScore = 100 * gameState.level;
                            if (gameState.activePowerUpEffects.multiplier) {
                                baseScore = Math.floor(baseScore * gameState.activePowerUpEffects.multiplier);
                            }
                            gameState.score += baseScore;
                            
                            updateHUD();
                            
                            // Check level complete
                            if (gameState.starsCollected >= gameState.totalStars) {
                                gameState.score += gameState.lives * 300;
                                setTimeout(showLevelComplete, 500);
                            }
                        }
                    }
                }
            });
            
            // Update and animate obstacles
            obstacles.forEach(obstacle => {
                if (obstacle.userData.isMoving) {
                    const offset = Math.sin(time * obstacle.userData.moveSpeed) * obstacle.userData.moveRange;
                    if (obstacle.userData.moveAxis === 'x') {
                        obstacle.position.x = obstacle.userData.baseX + offset;
                    } else {
                        obstacle.position.z = obstacle.userData.baseZ + offset;
                    }
                }
                
                // Check collision with player
                if (invincibilityTime <= 0 && !shieldActive && checkCollision(
                    playerPhysics.position,
                    playerPhysics.radius,
                    obstacle.position,
                    obstacle.userData.width,
                    obstacle.userData.depth
                )) {
                    // Check if shield should activate
                    if (gameState.activePowerUpEffects.shieldDuration && !shieldActive) {
                        shieldTimeRemaining = gameState.activePowerUpEffects.shieldDuration;
                        shieldActive = true;
                        
                        // Still take damage but less
                        gameState.lives--;
                    } else {
                        gameState.lives--;
                    }
                    invincibilityTime = 2;
                    
                    // Push player back
                    const dx = playerPhysics.position.x - obstacle.position.x;
                    const dz = playerPhysics.position.z - obstacle.position.z;
                    const len = Math.sqrt(dx * dx + dz * dz) || 1;
                    playerPhysics.velocity.x += (dx / len) * 0.5;
                    playerPhysics.velocity.z += (dz / len) * 0.5;
                    
                    updateHUD();
                    
                    // Flash effect
                    player.visible = false;
                    setTimeout(() => player.visible = true, 100);
                    setTimeout(() => player.visible = false, 200);
                    setTimeout(() => player.visible = true, 300);
                    
                    if (gameState.lives <= 0) {
                        showGameOver();
                    }
                }
            });
            
            // Update enemy AI - THE CHALLENGER - Pushes player toward walls/obstacles
            if (enemy && enemyData) {
                const toPlayer = new THREE.Vector3(
                    playerPhysics.position.x - enemyData.position.x,
                    0,
                    playerPhysics.position.z - enemyData.position.z
                );
                const distToPlayer = toPlayer.length();
                
                // Calculate steering toward player
                if (distToPlayer > 0.1) {
                    toPlayer.normalize();
                    
                    // Smart behavior: predict player movement for interception
                    if (enemyData.predictPlayer && speed > 0.03) {
                        const prediction = playerPhysics.velocity.clone().multiplyScalar(distToPlayer * 12);
                        toPlayer.add(prediction).normalize();
                    }
                    
                    // WALL HUNT MODE: Actively push player toward nearest wall
                    if (enemyData.wallHuntMode) {
                        // Find which wall is closest to player
                        const distToLeft = playerPhysics.position.x - (-arenaWidth/2);
                        const distToRight = arenaWidth/2 - playerPhysics.position.x;
                        const distToTop = arenaHeight/2 - playerPhysics.position.z;
                        const distToBottom = playerPhysics.position.z - (-arenaHeight/2);
                        
                        const minWallDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
                        
                        // Add steering force toward the nearest wall (cut off escape)
                        if (minWallDist < 5) {
                            if (minWallDist === distToLeft) {
                                // Push player toward left wall
                                toPlayer.x -= 0.4;
                            } else if (minWallDist === distToRight) {
                                // Push player toward right wall
                                toPlayer.x += 0.4;
                            } else if (minWallDist === distToTop) {
                                // Push player toward top wall
                                toPlayer.z += 0.4;
                            } else if (minWallDist === distToBottom) {
                                // Push player toward bottom wall
                                toPlayer.z -= 0.4;
                            }
                            toPlayer.normalize();
                        }
                    }
                    
                    // OBSTACLE HUNTING: Try to push player toward obstacles
                    const obstaclePushForce = new THREE.Vector3();
                    if (enemyData.smartBehavior) {
                        obstacles.forEach(obs => {
                            const toObstacle = new THREE.Vector3(
                                obs.position.x - enemyData.position.x,
                                0,
                                obs.position.z - enemyData.position.z
                            );
                            const distToObstacle = toObstacle.length();
                            
                            // If obstacle is between enemy and player, push toward it
                            if (distToObstacle < 6) {
                                const toPlayerFromObstacle = new THREE.Vector3(
                                    playerPhysics.position.x - obs.position.x,
                                    0,
                                    playerPhysics.position.z - obs.position.z
                                );
                                
                                // Check if obstacle is roughly between enemy and player
                                const angleToObstacle = Math.atan2(toObstacle.x, toObstacle.z);
                                const angleToPlayer = Math.atan2(toPlayer.x, toPlayer.z);
                                const angleDiff = Math.abs(angleToObstacle - angleToPlayer);
                                
                                if (angleDiff < Math.PI / 3 && toPlayerFromObstacle.dot(toObstacle) > 0) {
                                    // Push toward obstacle to trap player
                                    obstaclePushForce.add(toObstacle.normalize().multiplyScalar(0.5));
                                }
                            }
                        });
                    }
                    
                    // Wall avoidance (enemy stays in arena but pushes player to edges)
                    const wallAvoidance = new THREE.Vector3();
                    if (enemyData.position.x < -arenaWidth/2 + 1.5) wallAvoidance.x += 0.3;
                    if (enemyData.position.x > arenaWidth/2 - 1.5) wallAvoidance.x -= 0.3;
                    if (enemyData.position.z < -arenaHeight/2 + 1.5) wallAvoidance.z += 0.3;
                    if (enemyData.position.z > arenaHeight/2 - 1.5) wallAvoidance.z -= 0.3;
                    
                    // Combine all forces: chase toward player + push toward obstacles/walls + wall avoidance
                    const steering = toPlayer.clone();
                    steering.add(obstaclePushForce);
                    steering.add(wallAvoidance.multiplyScalar(0.2));
                    steering.normalize();
                    
                    // Apply steering to velocity
                    enemyData.velocity.x += steering.x * enemyData.acceleration;
                    enemyData.velocity.z += steering.z * enemyData.acceleration;
                    
                    // Limit enemy speed
                    const enemySpeed = enemyData.velocity.length();
                    if (enemySpeed > enemyData.speed) {
                        enemyData.velocity.multiplyScalar(enemyData.speed / enemySpeed);
                    }
                }
                
                // Update enemy position
                enemyData.position.add(enemyData.velocity);
                
                // Keep enemy in bounds
                enemyData.position.x = Math.max(-arenaWidth/2 + 1.5, Math.min(arenaWidth/2 - 1.5, enemyData.position.x));
                enemyData.position.z = Math.max(-arenaHeight/2 + 1.5, Math.min(arenaHeight/2 - 1.5, enemyData.position.z));
                
                enemy.position.copy(enemyData.position);
                
                // Rotate enemy to face player
                const toPlayerX = playerPhysics.position.x - enemyData.position.x;
                const toPlayerZ = playerPhysics.position.z - enemyData.position.z;
                const angle = Math.atan2(toPlayerX, toPlayerZ);
                enemy.rotation.y = angle;
                
                // Check collision with player - STRONGER PUSH
                if (invincibilityTime <= 0 && !shieldActive && checkCircleCollision(
                    playerPhysics.position,
                    playerPhysics.radius,
                    enemyData.position,
                    enemyData.radius
                )) {
                    // Check if shield should activate
                    if (gameState.activePowerUpEffects.shieldDuration && !shieldActive) {
                        shieldTimeRemaining = gameState.activePowerUpEffects.shieldDuration;
                        shieldActive = true;
                        gameState.lives--;
                    } else {
                        gameState.lives--;
                    }
                    invincibilityTime = 2;
                    
                    // Push player HARD in the direction of enemy movement
                    const pushDir = enemyData.velocity.clone().normalize();
                    if (pushDir.length() > 0.01) {
                        // Strong push based on level
                        playerPhysics.velocity.x += pushDir.x * enemyData.pushForce;
                        playerPhysics.velocity.z += pushDir.z * enemyData.pushForce;
                    } else {
                        // If enemy isn't moving, push away from enemy position
                        const awayFromEnemy = new THREE.Vector3(
                            playerPhysics.position.x - enemyData.position.x,
                            0,
                            playerPhysics.position.z - enemyData.position.z
                        ).normalize();
                        playerPhysics.velocity.x += awayFromEnemy.x * (enemyData.pushForce * 0.8);
                        playerPhysics.velocity.z += awayFromEnemy.z * (enemyData.pushForce * 0.8);
                    }
                    
                    // Also push enemy back slightly (bounce)
                    enemyData.velocity.multiplyScalar(-0.3);
                    
                    updateHUD();
                    
                    // Flash effect
                    player.visible = false;
                    setTimeout(() => player.visible = true, 100);
                    setTimeout(() => player.visible = false, 200);
                    setTimeout(() => player.visible = true, 300);
                    
                    if (gameState.lives <= 0) {
                        showGameOver();
                    }
                }
            }
            
            // Update ADDITIONAL ENEMIES AI
            enemies.forEach((additionalEnemy, index) => {
                const enemyData = enemiesData[index];
                if (!enemyData) return;
                
                const toPlayer = new THREE.Vector3(
                    playerPhysics.position.x - enemyData.position.x,
                    0,
                    playerPhysics.position.z - enemyData.position.z
                );
                const distToPlayer = toPlayer.length();
                
                // Simple chase AI for additional enemies
                if (distToPlayer > 0.1) {
                    toPlayer.normalize();
                    
                    // Predict player movement if enabled
                    if (enemyData.predictPlayer && speed > 0.03) {
                        const prediction = playerPhysics.velocity.clone().multiplyScalar(distToPlayer * 10);
                        toPlayer.add(prediction).normalize();
                    }
                    
                    // Wall hunt mode - push player to walls
                    if (enemyData.wallHuntMode) {
                        const distToLeft = playerPhysics.position.x - (-arenaWidth/2);
                        const distToRight = arenaWidth/2 - playerPhysics.position.x;
                        const distToTop = arenaHeight/2 - playerPhysics.position.z;
                        const distToBottom = playerPhysics.position.z - (-arenaHeight/2);
                        
                        const minWallDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
                        
                        if (minWallDist < 4) {
                            if (minWallDist === distToLeft) toPlayer.x -= 0.3;
                            else if (minWallDist === distToRight) toPlayer.x += 0.3;
                            else if (minWallDist === distToTop) toPlayer.z += 0.3;
                            else if (minWallDist === distToBottom) toPlayer.z -= 0.3;
                            toPlayer.normalize();
                        }
                    }
                    
                    // Smart behavior - coordinate with main enemy
                    const separationForce = new THREE.Vector3();
                    if (enemyData.smartBehavior && enemiesData.length > 0) {
                        // Avoid other enemies
                        enemiesData.forEach((otherEnemyData, otherIndex) => {
                            if (otherIndex !== index) {
                                const toOther = new THREE.Vector3(
                                    enemyData.position.x - otherEnemyData.position.x,
                                    0,
                                    enemyData.position.z - otherEnemyData.position.z
                                );
                                const dist = toOther.length();
                                if (dist < 4 && dist > 0) {
                                    separationForce.add(toOther.normalize().multiplyScalar(0.3));
                                }
                            }
                        });
                    }
                    
                    // Avoid walls
                    const wallAvoidance = new THREE.Vector3();
                    if (enemyData.position.x < -arenaWidth/2 + 1.5) wallAvoidance.x += 0.3;
                    if (enemyData.position.x > arenaWidth/2 - 1.5) wallAvoidance.x -= 0.3;
                    if (enemyData.position.z < -arenaHeight/2 + 1.5) wallAvoidance.z += 0.3;
                    if (enemyData.position.z > arenaHeight/2 - 1.5) wallAvoidance.z -= 0.3;
                    
                    const steering = toPlayer.clone();
                    steering.add(separationForce);
                    steering.add(wallAvoidance.multiplyScalar(0.2));
                    steering.normalize();
                    
                    enemyData.velocity.x += steering.x * enemyData.acceleration;
                    enemyData.velocity.z += steering.z * enemyData.acceleration;
                    
                    const enemySpeed = enemyData.velocity.length();
                    if (enemySpeed > enemyData.speed) {
                        enemyData.velocity.multiplyScalar(enemyData.speed / enemySpeed);
                    }
                }
                
                enemyData.position.add(enemyData.velocity);
                
                // Keep in bounds
                enemyData.position.x = Math.max(-arenaWidth/2 + 1.5, Math.min(arenaWidth/2 - 1.5, enemyData.position.x));
                enemyData.position.z = Math.max(-arenaHeight/2 + 1.5, Math.min(arenaHeight/2 - 1.5, enemyData.position.z));
                
                additionalEnemy.position.copy(enemyData.position);
                
                // Rotate to face player
                const toPlayerX = playerPhysics.position.x - enemyData.position.x;
                const toPlayerZ = playerPhysics.position.z - enemyData.position.z;
                const angle = Math.atan2(toPlayerX, toPlayerZ);
                additionalEnemy.rotation.y = angle;
                
                // Collision with player
                if (invincibilityTime <= 0 && !shieldActive && checkCircleCollision(
                    playerPhysics.position,
                    playerPhysics.radius,
                    enemyData.position,
                    enemyData.radius
                )) {
                    // Check if shield should activate
                    if (gameState.activePowerUpEffects.shieldDuration && !shieldActive) {
                        shieldTimeRemaining = gameState.activePowerUpEffects.shieldDuration;
                        shieldActive = true;
                        gameState.lives--;
                    } else {
                        gameState.lives--;
                    }
                    invincibilityTime = 2;
                    
                    const pushDir = enemyData.velocity.clone().normalize();
                    if (pushDir.length() > 0.01) {
                        playerPhysics.velocity.x += pushDir.x * enemyData.pushForce;
                        playerPhysics.velocity.z += pushDir.z * enemyData.pushForce;
                    } else {
                        const awayFromEnemy = new THREE.Vector3(
                            playerPhysics.position.x - enemyData.position.x,
                            0,
                            playerPhysics.position.z - enemyData.position.z
                        ).normalize();
                        playerPhysics.velocity.x += awayFromEnemy.x * (enemyData.pushForce * 0.8);
                        playerPhysics.velocity.z += awayFromEnemy.z * (enemyData.pushForce * 0.8);
                    }
                    
                    enemyData.velocity.multiplyScalar(-0.3);
                    
                    updateHUD();
                    
                    player.visible = false;
                    setTimeout(() => player.visible = true, 100);
                    setTimeout(() => player.visible = false, 200);
                    setTimeout(() => player.visible = true, 300);
                    
                    if (gameState.lives <= 0) {
                        showGameOver();
                    }
                }
            });
            
            // Check collision with moving walls
            movingWalls.forEach((wall, index) => {
                const wallData = movingWallsData[index];
                if (!wallData) return;
                
                const width = wallData.isHorizontal ? wallData.length : wallData.thickness;
                const depth = wallData.isHorizontal ? wallData.thickness : wallData.length;
                
                if (invincibilityTime <= 0 && !shieldActive && checkCollision(
                    playerPhysics.position,
                    playerPhysics.radius,
                    wall.position,
                    width,
                    depth
                )) {
                    // Check if shield should activate
                    if (gameState.activePowerUpEffects.shieldDuration && !shieldActive) {
                        shieldTimeRemaining = gameState.activePowerUpEffects.shieldDuration;
                        shieldActive = true;
                        gameState.lives--;
                    } else {
                        gameState.lives--;
                    }
                    invincibilityTime = 2;
                    
                    // Push player away from wall
                    const dx = playerPhysics.position.x - wall.position.x;
                    const dz = playerPhysics.position.z - wall.position.z;
                    const len = Math.sqrt(dx * dx + dz * dz) || 1;
                    playerPhysics.velocity.x += (dx / len) * 0.6;
                    playerPhysics.velocity.z += (dz / len) * 0.6;
                    
                    updateHUD();
                    
                    player.visible = false;
                    setTimeout(() => player.visible = true, 100);
                    setTimeout(() => player.visible = false, 200);
                    setTimeout(() => player.visible = true, 300);
                    
                    if (gameState.lives <= 0) {
                        showGameOver();
                    }
                }
            });
            
            // Update camera to follow player (smooth)
            const targetCamX = playerPhysics.position.x * 0.3;
            const targetCamZ = playerPhysics.position.z * 0.3 + 15;
            const targetCamY = cameraZoom.currentHeight; // Use zoom height

            camera.position.x += (targetCamX - camera.position.x) * 0.05;
            camera.position.y += (targetCamY - camera.position.y) * 0.05;
            camera.position.z += (targetCamZ - camera.position.z) * 0.05;
            camera.lookAt(playerPhysics.position.x * 0.5, 0, playerPhysics.position.z * 0.5);
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize game
        loadProgress();
        applyPowerUpEffects();
        gameState.lives = 3 + (gameState.activePowerUpEffects.extraLives || 0);
        generateLevel(1);
        animate();
    </script>
</body>
</html>
